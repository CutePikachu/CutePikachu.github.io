<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Haskell and functional programming - Tina blog</title><meta description="Enjoy learning haskell but not only haskell."><meta property="og:type" content="blog"><meta property="og:title" content="Haskell and functional programming"><meta property="og:url" content="https://cutepikachu.github.io/2020/08/01/Haskell/"><meta property="og:site_name" content="Tina blog"><meta property="og:description" content="Enjoy learning haskell but not only haskell."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.loli.net/2020/08/06/MLdbBflRi7sHG8e.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/tPKreTBIiY8HuVq.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/7zFBO4Ith8cuKJT.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/WCTwuMAhm7QHDvd.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/XzMvQbgn8wy3YdZ.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/t7hzkspYET83dwG.png"><meta property="og:image" content="https://i.loli.net/2020/08/08/2UzBCf5hT7EZLR9.png"><meta property="article:published_time" content="2020-08-01T06:00:00.000Z"><meta property="article:modified_time" content="2020-08-08T11:40:26.709Z"><meta property="article:author" content="Tina"><meta property="article:tag" content="Haskell"><meta property="article:tag" content="Functional Programming"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/08/06/MLdbBflRi7sHG8e.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cutepikachu.github.io/2020/08/01/Haskell/"},"headline":"Tina blog","image":["https://i.loli.net/2020/08/06/MLdbBflRi7sHG8e.png","https://i.loli.net/2020/08/08/tPKreTBIiY8HuVq.png","https://i.loli.net/2020/08/08/7zFBO4Ith8cuKJT.png","https://i.loli.net/2020/08/08/WCTwuMAhm7QHDvd.png","https://i.loli.net/2020/08/08/XzMvQbgn8wy3YdZ.png","https://i.loli.net/2020/08/08/t7hzkspYET83dwG.png","https://i.loli.net/2020/08/08/2UzBCf5hT7EZLR9.png"],"datePublished":"2020-08-01T06:00:00.000Z","dateModified":"2020-08-08T11:40:26.709Z","author":{"@type":"Person","name":"Tina"},"description":"Enjoy learning haskell but not only haskell."}</script><link rel="canonical" href="https://cutepikachu.github.io/2020/08/01/Haskell/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Tina blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/projects">Projects</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-01T06:00:00.000Z" title="2020-08-01T06:00:00.000Z">2020-08-01</time><span class="level-item"><a class="link-muted" href="/categories/notes/">notes</a></span><span class="level-item">an hour read (About 12638 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Haskell and functional programming</h1><div class="content"><blockquote>
<p>Enjoy learning haskell but not only haskell.</p>
</blockquote>
<a id="more"></a>
<h1 id="Haskell-Introduction"><a href="#Haskell-Introduction" class="headerlink" title="Haskell Introduction"></a>Haskell Introduction</h1><p>In this course we use Haskell, because it is the most widespread language with good support for mathematically structured programming.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">f</span> x = (x &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>First $x$ is the input and the RHS of the equation is the Output.</p>
</blockquote>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>In mathematics, we treat $log_{10}(x)$ and $log_2 (x)$ and ln(x) as separate functions.</p>
<p>In Haskell, we have a single function logBase that, given a number n, produces a function for $log_n(x)$</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">log10</span> :: <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">log10</span> = logBase <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title">log2</span> :: <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">log2</span> = logBase <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">ln</span> :: <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">ln</span> = logBase <span class="number">2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="title">logBase</span> :: <span class="type">Double</span> -&gt; <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Function application associates to the left in Haskell, so:</p>
<p>logBase 2 64 ≡ (logBase 2) 64</p>
</blockquote>
<p>Functions of more than one argument are usually written this way in Haskell, but it is possible to use tuples instead…</p>
<h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><p>Tuples are another way to take multiple inputs or produce multiple outputs:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">toCartesian</span> :: (<span class="type">Double</span>, <span class="type">Double</span>) -&gt; (<span class="type">Double</span>, <span class="type">Double</span>)</span><br><span class="line"><span class="title">toCartesian</span> (r, theta) = (x, y)</span><br><span class="line">  <span class="keyword">where</span> x = r * cos theta</span><br><span class="line">        y = r * sin theta</span><br></pre></td></tr></table></figure>

<blockquote>
<p>N.B: The order of bindings doesn’t matter. Haskell functions have no side effects, they just return a result. There’s no notion of time(no notion of sth happen before sth else).</p>
</blockquote>
<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><p>In addition to returning functions, functions can take other functions as arguments:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">twice</span> :: (a -&gt; a) -&gt; (a -&gt; a)</span><br><span class="line"><span class="title">twice</span> f a = f (f a)</span><br><span class="line"></span><br><span class="line"><span class="title">double</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">double</span> x = x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">quadruple</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">quadruple</span> = twice double</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Haskell concrete types are written in upper case like Int, Bool, and in lower case if they stand for any type.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">  twice twice double 3</span></span><br><span class="line"><span class="comment"> == (twice twice double) 3</span></span><br><span class="line"><span class="comment"> == (twice (twice double)) 3</span></span><br><span class="line"><span class="comment"> == (twice quadruple) 3</span></span><br><span class="line"><span class="comment"> == quadrauple (quadruple 3)</span></span><br><span class="line"><span class="comment"> == 48</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Haskell makes extensive use of lists, constructed using square brackets. Each list element must be of the same type.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">True</span>, <span class="type">False</span>, <span class="type">True</span>] :: [<span class="type">Bool</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>+<span class="number">1</span>]         :: [<span class="type">Int</span>]</span><br><span class="line">[sin, cos]          :: [<span class="type">Double</span> -&gt; <span class="type">Double</span>]</span><br><span class="line">[ (<span class="number">3</span>,’a’),(<span class="number">4</span>,’b’) ] :: [(<span class="type">Int</span>, <span class="type">Char</span>)]</span><br></pre></td></tr></table></figure>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>A useful function is map, which, given a function, applies it to each element of a list:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> not [<span class="type">True</span>, <span class="type">False</span>, <span class="type">True</span>] = [<span class="type">False</span>, <span class="type">True</span>, <span class="type">False</span>]</span><br><span class="line"><span class="title">map</span> negate [<span class="number">3</span>, <span class="number">-2</span>, <span class="number">4</span>]       = [<span class="number">-3</span>, <span class="number">2</span>, <span class="number">-4</span>]</span><br><span class="line"><span class="title">map</span> (\x -&gt; x + <span class="number">1</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>The last example here uses a lambda expression to define a one-use function without giving it a name.</p>
<p><strong><em>What’s the type of map?</em></strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure>



<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>The type String in Haskell is just a list of characters:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">String</span> = [<span class="type">Char</span>]</span></span><br></pre></td></tr></table></figure>

<p>This is a type synonym, like a typedef in C.</p>
<p>Thus: <code>&quot;hi!&quot; == [&#39;h&#39;, &#39;i&#39;, &#39;!&#39;]</code></p>
<p><strong>Practice</strong></p>
<p>Word Frequencies</p>
<p>Given a number $n$ and a string $s$, generate a report (in String form) that lists the $n$ most common words in the string $s$.</p>
<p>We must: </p>
<ul>
<li>Break the input string into words.</li>
<li>Convert the words to lowercase.</li>
<li>Sort the words.</li>
<li>Count adjacent runs of the same word.</li>
<li>Sort by size of the run.</li>
<li>Take the first $n$ runs in the sorted list.</li>
<li>Generate a report.</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char(<span class="title">toLower</span>)</span><br><span class="line"><span class="keyword">import</span> Data.List(<span class="title">group</span>,<span class="title">sort</span>,<span class="title">sortBy</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">breakIntoWords</span> :: <span class="type">String</span> -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">breakIntoWords</span> = words</span><br><span class="line"></span><br><span class="line"><span class="title">convertIntoLowercase</span> :: [[<span class="type">Char</span>]] -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">convertIntoLowercase</span> = map (map toLower)</span><br><span class="line"></span><br><span class="line"><span class="title">sortWords</span> :: [<span class="type">String</span>] -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">sortWords</span> = sort</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Run</span> = (<span class="type">Int</span>, <span class="type">String</span>)</span></span><br><span class="line"><span class="title">countAdjacentRuns</span> :: [<span class="type">String</span>] -&gt; [<span class="type">Run</span>]</span><br><span class="line"><span class="title">countAdjacentRuns</span> = convertToRuns . groupAdjacentRuns </span><br><span class="line"></span><br><span class="line"><span class="comment">-- ["hello","hello","world"] --&gt; [["hello","hello"],["world"]]</span></span><br><span class="line"></span><br><span class="line"><span class="title">groupAdjacentRuns</span> :: [<span class="type">String</span>] -&gt; [[<span class="type">String</span>]]</span><br><span class="line"><span class="title">groupAdjacentRuns</span> = group</span><br><span class="line"></span><br><span class="line"><span class="comment">-- head :: [a] -&gt; a</span></span><br><span class="line"></span><br><span class="line"><span class="title">convertToRuns</span> :: [[<span class="type">String</span>]] -&gt; [<span class="type">Run</span>]</span><br><span class="line"><span class="title">convertToRuns</span> = map (\ls-&gt; (length ls, head ls))</span><br><span class="line"></span><br><span class="line"><span class="title">sortByRunSize</span> :: [<span class="type">Run</span>] -&gt; [<span class="type">Run</span>]</span><br><span class="line"><span class="title">sortByRunSize</span> = sortBy (\(l1, w1) (l2, w2) -&gt; compare l2 l1)</span><br><span class="line"></span><br><span class="line"><span class="title">takeFirst</span> :: <span class="type">Int</span> -&gt; [<span class="type">Run</span>] -&gt; [<span class="type">Run</span>]</span><br><span class="line"><span class="title">takeFirst</span> = take </span><br><span class="line"></span><br><span class="line"><span class="title">generateReport</span> :: [<span class="type">Run</span>] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">generateReport</span> = unlines . map (\(l,w) -&gt; w ++ <span class="string">":"</span> ++ show l  ) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- (\x -&gt; f x) == f</span></span><br><span class="line"></span><br><span class="line"><span class="title">mostCommonWords</span> :: <span class="type">Int</span> -&gt; (<span class="type">String</span> -&gt; <span class="type">String</span>)</span><br><span class="line"><span class="title">mostCommonWords</span> n =</span><br><span class="line">     generateReport</span><br><span class="line">   . takeFirst n</span><br><span class="line">   . sortByRunSize </span><br><span class="line">   . countAdjacentRuns</span><br><span class="line">   . sortWords</span><br><span class="line">   . convertIntoLowercase  </span><br><span class="line">   . breakIntoWords</span><br></pre></td></tr></table></figure>



<h2 id="Functional-Composition"><a href="#Functional-Composition" class="headerlink" title="Functional Composition"></a>Functional Composition</h2><p>We used function composition to combine our functions together. The mathematical $(f ◦ g)(x)$ is written $(f . g) x$ in Haskell.</p>
<p>In Haskell, operators like function composition are themselves functions. You can define your own!</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Vector addition</span></span><br><span class="line">(.+) :: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">(x1, y1) .+ (x2, y2) = (x1 + x2, y1 + y2)</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>) .+ (<span class="number">1</span>,<span class="number">1</span>) == (<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>You could even have defined function composition yourself if it didn’t already exist:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span><br><span class="line">(f . g) x = f (g x)</span><br></pre></td></tr></table></figure>



<h2 id="Lists-1"><a href="#Lists-1" class="headerlink" title="Lists"></a>Lists</h2><p>How were all of those list functions we just used implemented?</p>
<p>Lists are singly-linked lists in Haskell. </p>
<blockquote>
<p>The empty list is written as [] and a list node is written as x : xs. </p>
<p>The value x is called the head and the rest of the list xs is called the tail. Thus:</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hi!"</span> == ['h', 'i', '!'] == 'h':('i':('!':[]))</span><br><span class="line">                         == 'h' : 'i' : '!' : []</span><br></pre></td></tr></table></figure>

<p>When we define recursive functions on lists, we use the last form for pattern matching:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> f []     = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure>

<p>We can evaluate programs equationally:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">map toUpper "hi!" ≡ map toUpper (’h’:"i!")</span></span><br><span class="line"><span class="comment">                  ≡ toUpper ’h’ : map toUpper "i!"</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : map toUpper "i!"</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : map toUpper (’i’:"!")</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : toUpper ’i’ : map toUpper "!"</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : ’I’ : map toUpper "!"</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : ’I’ : map toUpper (’!’:"")</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : ’I’ : ’!’ : map toUpper ""</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : ’I’ : ’!’ : map toUpper []</span></span><br><span class="line"><span class="comment">                  ≡ ’H’ : ’I’ : ’!’ : []</span></span><br><span class="line"><span class="comment">                  ≡ "HI!"</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="List-Functions"><a href="#List-Functions" class="headerlink" title="List Functions"></a>List Functions</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- in maths: f(g(x)) == (f o g)(x)</span></span><br><span class="line"></span><br><span class="line"><span class="title">myMap</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">myMap</span> f []     = []</span><br><span class="line"><span class="title">myMap</span> f (x:xs) = (f x)  :  (myMap f xs)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1 : 2 : 3 : []</span></span><br><span class="line"><span class="comment">-- 1 + 2 + 3 + 0</span></span><br><span class="line"><span class="title">sum'</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sum'</span> []     = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ["hello","world","!"] -&gt; "helloworld!"</span></span><br><span class="line"><span class="comment">-- "hello":"world":"!":[]</span></span><br><span class="line"><span class="comment">-- "hello"++"world"++"!"++[]</span></span><br><span class="line"></span><br><span class="line"><span class="title">concat'</span> :: [[a]] -&gt; [a]</span><br><span class="line"><span class="title">concat'</span> []        = []</span><br><span class="line"><span class="title">concat'</span> (xs:xss)  = xs ++ concat xss</span><br><span class="line"></span><br><span class="line"><span class="title">foldr'</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr'</span> f z []     = z</span><br><span class="line"><span class="title">foldr'</span> f z (x:xs) = x `f` (foldr' f z xs)</span><br><span class="line"></span><br><span class="line"><span class="title">sum''</span> = foldr' (+) <span class="number">0</span></span><br><span class="line"><span class="title">concat''</span> = foldr' (++) []</span><br><span class="line"></span><br><span class="line"><span class="title">filter'</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter'</span> p [] = []</span><br><span class="line"><span class="comment">-- filter' p (x:xs) = if p x then x : filter' p xs </span></span><br><span class="line"><span class="comment">--                          else filter' p xs</span></span><br><span class="line"><span class="title">filter'</span> p (x:xs) </span><br><span class="line">   | p x       = x : filter' p xs</span><br><span class="line">   | otherwise = filter' p xs</span><br></pre></td></tr></table></figure>



<h1 id="Induction"><a href="#Induction" class="headerlink" title="Induction"></a>Induction</h1><p>Suppose we want to prove that a property $P(n)$ holds for all natural numbers $n$. Remember that the set of natural numbers $N$ can be defined as follows:</p>
<p><strong><em>Definition of Natural Numbers</em></strong></p>
<blockquote>
<p>Inductive definition of Natural numbers</p>
</blockquote>
<ol>
<li>0 is a natural number.</li>
<li>For any natural number $n, n + 1$ is also a natural number</li>
</ol>
<p>Therefore, to show $P(n)$ for all $n$, it suffices to show:</p>
<ol>
<li><p>$P(0)$ (the base case), and</p>
</li>
<li><p>assuming $P(k)$ (the inductive hypothesis),</p>
<p>$⇒ P(k + 1)$ (the inductive case).</p>
</li>
</ol>
<p><strong>Induction on Lists</strong></p>
<p>Haskell lists can be defined similarly to natural numbers</p>
<p><strong><em>Definition of Haskell Lists</em></strong></p>
<ol>
<li>[] is a list.</li>
<li>For any list xs, x:xs is also a list (for any item x).</li>
</ol>
<p>This means, if we want to prove that a property P(ls) holds for all lists ls, it suffices to show:</p>
<ol>
<li>P([]) (the base case)</li>
<li>P(x:xs) for all items x, assuming the inductive hypothesis P(xs)</li>
</ol>
<h1 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h1><p>So far, we have seen type synonyms using the <code>type</code> keyword. For a graphics library, we might define:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Point</span>  = (<span class="type">Float</span>, <span class="type">Float</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Vector</span> = (<span class="type">Float</span>, <span class="type">Float</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Line</span>   = (<span class="type">Point</span>, <span class="type">Point</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Colour</span> = (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) <span class="comment">-- RGBA</span></span></span><br><span class="line"><span class="title">movePoint</span> :: <span class="type">Point</span> -&gt; <span class="type">Vector</span> -&gt; <span class="type">Point</span></span><br><span class="line"><span class="title">movePoint</span> (x,y) (dx,dy) = (x + dx, y + dy)</span><br></pre></td></tr></table></figure>

<p>But these definitions allow Points and Vectors to be used interchangeably, increasing the likelihood of errors.</p>
<p>We can define our own compound types using the <code>data</code> keyword:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br><span class="line"><span class="title">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>First Point is the type name</p>
<p>Second Point is Constructor name</p>
<p>Floats are Constructor argument types</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> = <span class="type">Vector</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br><span class="line"><span class="title">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"><span class="title">movePoint</span> :: <span class="type">Point</span> -&gt; <span class="type">Vector</span> -&gt; <span class="type">Point</span></span><br><span class="line"><span class="title">movePoint</span> (<span class="type">Point</span> x y) (<span class="type">Vector</span> dx dy)</span><br><span class="line">= <span class="type">Point</span> (x + dx) (y + dy)</span><br></pre></td></tr></table></figure>

<h2 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h2><p>We could define Colour similarly:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Colour</span> = <span class="type">Colour</span> <span class="type">Int</span> <span class="type">Int</span> <span class="type">Int</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure>

<p>But this has so many parameters, it’s hard to tell which is which. Haskell lets us declare these types as <code>records</code>, which is identical to the declaration style on the previous slide, but also gives us projection functions and record syntax:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Colour</span> = <span class="type">Colour</span> &#123; <span class="title">redC</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                      , <span class="title">greenC</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                      , <span class="title">blueC</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                      , <span class="title">opacityC</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                      &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span></span><br></pre></td></tr></table></figure>

<p>Here, the code <code>redC (Colour 255 128 0 255)</code> gives 255.</p>
<h2 id="Enumeration-Types"><a href="#Enumeration-Types" class="headerlink" title="Enumeration Types"></a>Enumeration Types</h2><p>Similar to enums in C and Java, we can define types to have one of a set of predefined values:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">LineStyle</span> = <span class="type">Solid</span></span></span><br><span class="line">                | <span class="type">Dashed</span></span><br><span class="line">                | <span class="type">Dotted</span></span><br><span class="line">                <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FillStyle</span> = <span class="type">SolidFill</span> | <span class="type">NoFill</span></span></span><br><span class="line">                  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br></pre></td></tr></table></figure>

<p>Types with more than one constructor are called <code>sum types</code></p>
<h3 id="Algebraic-Data-Types"><a href="#Algebraic-Data-Types" class="headerlink" title="Algebraic Data Types"></a>Algebraic Data Types</h3><p>Just as the Point constructor took two Float arguments, constructors for sum types can take parameters too, allowing us to model different kinds of shape:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PictureObject</span></span></span><br><span class="line">    = <span class="type">Path</span> [<span class="type">Point</span>] <span class="type">Colour</span> <span class="type">LineStyle</span></span><br><span class="line">    | <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> <span class="type">Colour</span> <span class="type">LineStyle</span> <span class="type">FillStyle</span></span><br><span class="line">    | <span class="type">Polygon</span> [<span class="type">Point</span>] <span class="type">Colour</span> <span class="type">LineStyle</span> <span class="type">FillStyle</span></span><br><span class="line">    | <span class="type">Ellipse</span> <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span><br><span class="line">              <span class="type">Colour</span> <span class="type">LineStyle</span> <span class="type">FillStyle</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Picture</span> = [<span class="type">PictureObject</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="Recursive-and-Parametric-Types"><a href="#Recursive-and-Parametric-Types" class="headerlink" title="Recursive and Parametric Types"></a>Recursive and Parametric Types</h2><p>Data types can also be defined with parameters, such as the well known Maybe type, defined in the standard library:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Just</span> a | <span class="type">Nothing</span></span></span><br></pre></td></tr></table></figure>

<p>Types can also be recursive. If lists weren’t already defined in the standard library, we could define them ourselves:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Nil</span> | <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure>

<p>We can even define natural numbers, where 2 is encoded as Succ(Succ Zero):</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Natural</span> = <span class="type">Zero</span> | <span class="type">Succ</span> <span class="type">Natural</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Types-in-Design"><a href="#Types-in-Design" class="headerlink" title="Types in Design"></a>Types in Design</h2><blockquote>
<p>Make illegal states unrepresentable. </p>
<p>​                     – Yaron Minsky (of Jane Street)</p>
</blockquote>
<p>Choose types that constrain your implementation as much as possible. Then failure scenarios are eliminated automatically.</p>
<h2 id="Partial-Functions"><a href="#Partial-Functions" class="headerlink" title="Partial Functions"></a>Partial Functions</h2><blockquote>
<p>A partial function is a function not defined for all possible inputs.</p>
</blockquote>
<p>Partial functions are to be avoided, because they cause your program to crash if undefined cases are encountered. To eliminate partiality, we must either:</p>
<ul>
<li><p>enlarge the codomain, usually with a <code>Maybe</code> type:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">safeHead</span> :: [a] -&gt; <span class="type">Maybe</span> a </span><br><span class="line"><span class="title">safeHead</span> (x:xs) = <span class="type">Just</span> x</span><br><span class="line"><span class="title">safeHead</span> [] = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>constrain the domain to be more specific:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">safeHead'</span> :: <span class="type">NonEmpty</span> a -&gt; a</span><br><span class="line"><span class="title">safeHead'</span> (<span class="type">One</span> a)    = a</span><br><span class="line"><span class="title">safeHead'</span> (<span class="type">Cons</span> a _) = a</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonEmpty</span> a = <span class="type">One</span> a | <span class="type">Cons</span> a (<span class="type">NonEmpty</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="Type-Classes"><a href="#Type-Classes" class="headerlink" title="Type Classes"></a>Type Classes</h1><p>You have already seen functions such as: <code>compare</code>, <code>(==)</code>, <code>(+)</code>, <code>(show)</code></p>
<p>that work on multiple types, and their corresponding constraints on type variables Ord, Eq, Num and Show.</p>
<p>These constraints are called <code>type classes</code>, and can be thought of as a set of types for which certain operations are implemented.</p>
<h2 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h2><blockquote>
<p>The Show type class is a set of types that can be converted to strings. </p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Show</span> a <span class="keyword">where</span></span> <span class="comment">-- nothing to do with OOP</span></span><br><span class="line">  show :: a -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>

<p>Types are added to the type class as an <em>instance</em> like so:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  show <span class="type">True</span> = <span class="string">"True"</span></span><br><span class="line">  show <span class="type">False</span> = <span class="string">"False"</span></span><br></pre></td></tr></table></figure>

<p>We can also define instances that depend on other instances:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">Just</span> x) = <span class="string">"Just "</span> ++ show x</span><br><span class="line">  show <span class="type">Nothing</span> = <span class="string">"Nothing"</span></span><br></pre></td></tr></table></figure>

<p>Fortunately for us, Haskell supports automatically <code>deriving</code> instances for some classes, including <code>Show</code>.</p>
<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><blockquote>
<p>Type classes can also overload based on the type returned.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Read</span> a <span class="keyword">where</span></span></span><br><span class="line">  read :: <span class="type">String</span> -&gt; a</span><br></pre></td></tr></table></figure>

<h2 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h2><blockquote>
<p>A semigroup is a pair of a set S and an operation • : S → S → S where the operation</p>
<ul>
<li>s associative.</li>
</ul>
<p>Associativity is defined as, for all a, b, c:</p>
<p>(a • (b • c)) = ((a • b) • c)</p>
</blockquote>
<p>Haskell has a type class for semigroups! The associativity law is enforced only by programmer discipline:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> s <span class="keyword">where</span></span></span><br><span class="line">(&lt;&gt;) :: s -&gt; s -&gt; s</span><br><span class="line"><span class="comment">-- Law: (&lt;&gt;) must be associative.</span></span><br></pre></td></tr></table></figure>

<p>What instances can you think of? Lists &amp; ++, numbers and +, numbers and *</p>
<p><strong>Example:</strong></p>
<p>Lets implement additive colour mixing:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Colour</span> <span class="keyword">where</span></span></span><br><span class="line"><span class="type">Colour</span> r1 g1 b1 a1 &lt;&gt; <span class="type">Colour</span> r2 g2 b2 a2</span><br><span class="line">     = <span class="type">Colour</span> (mix r1 r2)</span><br><span class="line">              (mix g1 g2)</span><br><span class="line">              (mix b1 b2)</span><br><span class="line">              (mix a1 a2)</span><br><span class="line"><span class="title">where</span></span><br><span class="line">  mix x1 x2 = min <span class="number">255</span> (x1 + x2)</span><br></pre></td></tr></table></figure>

<p>Observe that associativity is satisfied.</p>
<h2 id="Moniod"><a href="#Moniod" class="headerlink" title="Moniod"></a>Moniod</h2><blockquote>
<p>A monoid is a semigroup (S, •) equipped with a special identity element z : S such that x • z = x and z • y = y for all x, y.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Semigroup</span> <span class="title">a</span>) =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span></span><br><span class="line">  mempty :: a</span><br><span class="line"><span class="type">For</span> colours, the identity element is transparent black:</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Colour</span> <span class="keyword">where</span></span></span><br><span class="line">  mempty = <span class="type">Colour</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>For each of the semigroups discussed previously(lists, num and +, num and *): </p>
<ul>
<li>Are they monoids? Yes</li>
<li>If so, what is the identity element? [], 0, 1</li>
</ul>
<p>Are there any semigroups that are not monoids? Maximum</p>
<h2 id="Newtypes"><a href="#Newtypes" class="headerlink" title="Newtypes"></a>Newtypes</h2><p>There are multiple possible monoid instances for numeric types like Integer:</p>
<ul>
<li>The operation (+) is associative, with identity element 0</li>
<li>The operation (*) is associative, with identity element 1</li>
</ul>
<p>Haskell doesn’t use any of these, because there can be only <strong>one</strong> instance per type per class in the entire program (including all dependencies and libraries used).</p>
<p>A common technique is to define a separate type that is represented identically to the original type, but can have its own, different type class instances.</p>
<p>In Haskell, this is done with the newtype keyword.</p>
<p>A newtype declaration is much like a data declaration except that there can be only one constructor and it must take exactly one argument:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Score</span> = <span class="type">S</span> <span class="type">Integer</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Score</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="type">S</span> x &lt;&gt; <span class="type">S</span> y = <span class="type">S</span> (x + y)</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Score</span> <span class="keyword">where</span></span></span><br><span class="line">  mempty = <span class="type">S</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Here, Score is represented identically to Integer, and thus no performance penalty is incurred to convert between them.</p>
<p><strong>In general, newtypes are a great way to prevent mistakes. Use them frequently!</strong></p>
</blockquote>
<h2 id="Ord"><a href="#Ord" class="headerlink" title="Ord"></a>Ord</h2><blockquote>
<p>Ord is a type class for inequality comparison</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Ord</span> a <span class="keyword">where</span></span></span><br><span class="line"> (&lt;=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>

<p>What laws should instances satisfy?</p>
<p>For all x, y, and z:</p>
<ul>
<li>Reflexivity: x &lt;= x</li>
<li>Transitivity: If x &lt;= y and y &lt;= z then x &lt;= z</li>
<li>Antisymmetry: If x &lt;= y and y &lt;= x then x == y.</li>
<li>Totality: Either x &lt;= y or y &lt;= x</li>
</ul>
<blockquote>
<p>Relations that satisfy these four properties are called total orders(most are total orders). Without the fourth (totality), they are called <em>partial orders</em>(e.g. division).</p>
</blockquote>
<h2 id="Eq"><a href="#Eq" class="headerlink" title="Eq"></a>Eq</h2><blockquote>
<p>Eq is a type class for equality or equivalence</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">  (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>

<p>What laws should instances satisfy?</p>
<p>For all x, y, and z:</p>
<ul>
<li>Reflexivity: x == x.</li>
<li>Transitivity: If x == y and y == z then x == z.</li>
<li>Symmetry: If x == y then y == x.</li>
</ul>
<p>Relations that satisfy these are called equivalence relations.</p>
<p>Some argue that the Eq class should be only for equality, requiring stricter laws like:</p>
<p>If x == y then f x == f y for all functions f</p>
<p>But this is debated.</p>
<h1 id="functor" style="text-decoration: none;">Funtors</h1>

<h2 id="Types-and-Values"><a href="#Types-and-Values" class="headerlink" title="Types and Values"></a>Types and Values</h2><p>Haskell is actually comprised of two languages.</p>
<ul>
<li>The value-level language, consisting of expressions such as if, let, 3 etc.</li>
<li>The type-level language, consisting of types Int, Bool, synonyms like String, and type constructors like Maybe, (-&gt;), [ ] etc</li>
</ul>
<p>This type level language itself has a type system!</p>
<h2 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h2><p>Just as terms in the value level language are given types, terms in the type level language are given kinds.</p>
<p>The most basic kind is written as *.</p>
<ul>
<li>Types such as Int and Bool have kind *.</li>
<li>Seeing as Maybe is parameterised by one argument, Maybe has kind * -&gt; *: given a type (e.g. Int), it will return a type (Maybe Int).</li>
</ul>
<h2 id="Lists-2"><a href="#Lists-2" class="headerlink" title="Lists"></a>Lists</h2><p>Suppose we have a function:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">toString</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>

<p>And we also have a function to give us some numbers:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getNumbers</span> :: <span class="type">Seed</span> -&gt; [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>

<p>How can I compose toString with getNumbers to get a function f of type <code>Seed -&gt; [String]</code>?</p>
<p>we use map: <code>f = map toString . getNumbers</code>.</p>
<p>What about return a Maybe Int? we can use maybe map</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maybeMap</span> :: (a -&gt; b) -&gt; <span class="type">Maybe</span> a -&gt; <span class="type">Maybe</span> b</span><br><span class="line"><span class="title">maybeMap</span> f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">maybeMap</span> f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">maybeMap</span> f mx = <span class="keyword">case</span> mx <span class="keyword">of</span></span><br><span class="line">                  <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">                  <span class="type">Just</span> x  -&gt; <span class="type">Just</span> (f x)</span><br></pre></td></tr></table></figure>

<p>We can generalise this using functor.</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>All of these functions are in the interface of a single type class, called Functor.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>

<p>Unlike previous type classes we’ve seen like Ord and Semigroup, Functor is over types of kind * -&gt; *.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Instance for tuples</span></span><br><span class="line"><span class="comment">-- type level:</span></span><br><span class="line"><span class="comment">-- (,) :: * -&gt; (* -&gt; *)</span></span><br><span class="line"><span class="comment">-- (,) x :: * -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) x) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; (,) x a -&gt; (,) x b</span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; (x,a) -&gt; (x, b)</span></span><br><span class="line">  fmap f (x,a) = (x, f a)</span><br><span class="line">  </span><br><span class="line"><span class="comment">-- instance for functions</span></span><br><span class="line"><span class="comment">-- type level:</span></span><br><span class="line"><span class="comment">-- (-&gt;) :: * -&gt; (* -&gt; *)</span></span><br><span class="line"><span class="comment">-- (-&gt;) x :: * -&gt; *</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) x) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; (-&gt;) x a -&gt; (-&gt;) x b</span></span><br><span class="line"><span class="comment">--  fmap :: (a -&gt; b) -&gt; (x -&gt; a) -&gt; (x -&gt; b)</span></span><br><span class="line">  fmap = (.)</span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>The functor type class must obey two laws:</p>
<ul>
<li>fmap id == id(indentity law)</li>
<li>fmap f . fmap g == fmap (f . g)(composition law, haskell use this law to do optimisation)</li>
</ul>
<p>In Haskell’s type system it’s impossible to make a total fmap function that satisfies the first law but violates the second.</p>
<p>This is due to <strong><em>parametricity</em></strong>.</p>
<h1 id="Property-Based-Testing"><a href="#Property-Based-Testing" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h1><h2 id="Free-Properties"><a href="#Free-Properties" class="headerlink" title="Free Properties"></a>Free Properties</h2><p>Haskell already ensures certain properties automatically with its language design and type system.</p>
<ul>
<li>Memory is accessed where and when it is safe and permitted to be accessed (memory safety).</li>
<li>Values of a certain static type will actually have that type at run time.</li>
<li>Programs that are well-typed will not lead to undefined behaviour (type safety).</li>
<li>All functions are pure: Programs won’t have side effects not declared in the type. (purely functional programming)</li>
</ul>
<p>⇒ Most of our properties focus on the logic of our program.</p>
<h2 id="Logical-Properties"><a href="#Logical-Properties" class="headerlink" title="Logical Properties"></a>Logical Properties</h2><p>We have already seen a few examples of logical properties.</p>
<p><strong>Example:</strong></p>
<ul>
<li>reverse is an involution: reverse (reverse xs) == xs</li>
<li>right identity for (++): xs ++ [] == xs</li>
<li>transitivity of (&gt;): (a &gt; b) ∧ (b &gt; c) ⇒ (a &gt; c)</li>
</ul>
<blockquote>
<p>The set of properties that capture all of our requirements for our program is called the <strong><em>functional correctness specification</em></strong> of our software.</p>
</blockquote>
<p>This defines what it means for software to be <strong>correct</strong>.</p>
<h2 id="Proofs"><a href="#Proofs" class="headerlink" title="Proofs"></a>Proofs</h2><p>Last week we saw some <em>proof methods</em> for Haskell programs. We could <em>prove</em> that our implementation meets its functional correctness specification.</p>
<p>Such proofs certainly offer a high degree of assurance, but:</p>
<ul>
<li>Proofs must make some assumptions about the environment and the semantics of the software.</li>
<li>Proof complexity grows with implementation complexity, sometimes drastically.</li>
<li>If software is <em>incorrect</em>, a proof attempt might simply become stuck: we do not always get constructive negative feedback.</li>
<li>Proofs can be labour and time intensive ($$$), or require highly specialised knowledge ($$$).</li>
</ul>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>Compared to proofs:</p>
<ul>
<li>Tests typically run the actual program, so requires fewer assumptions about the language semantics or operating environment.</li>
<li>Test complexity does not grow with implementation complexity, so long as the specification is unchanged.</li>
<li>Incorrect software when tested leads to immediate, debuggable counter examples.</li>
<li>Testing is typically cheaper and faster than proving.</li>
<li>Tests care about efficiency and computability, unlike proofs(e.g. termination is provable but not computable).</li>
</ul>
<p>We lose some assurance, but gain some convenience ($$$).</p>
<h2 id="Property-Based-Testing-1"><a href="#Property-Based-Testing-1" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h2><blockquote>
<p><strong>Key idea</strong>: Generate random input values, and test properties by running them.</p>
</blockquote>
<p><strong>Example(QuickCheck Property)</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">--                 Testable          </span></span><br><span class="line"><span class="comment">--                 Arbitrary    Testable</span></span><br><span class="line"><span class="comment">--                               Arbitrary    Testable</span></span><br><span class="line"><span class="title">prop_reverseApp</span> :: [<span class="type">Int</span>]     -&gt; ([<span class="type">Int</span>]     -&gt; <span class="type">Bool</span>)</span><br><span class="line"><span class="title">prop_reverseApp</span> xs ys =</span><br><span class="line">   reverse (xs ++ ys) == reverse ys ++ reverse xs</span><br><span class="line"></span><br><span class="line"><span class="title">divisible</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">divisible</span> x y = x `mod` y == <span class="number">0</span></span><br><span class="line"><span class="comment">-- or select different generators with modifier newtypes.</span></span><br><span class="line"><span class="title">prop_refl</span> :: <span class="type">Positive</span> <span class="type">Int</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">prop_refl</span> (<span class="type">Positive</span> x) = divisible x x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Encode pre-conditions with the (==&gt;) operator:</span></span><br><span class="line"><span class="title">prop_unwordsWords</span> s = unwords (words s) == s</span><br><span class="line"><span class="title">prop_wordsUnwords</span> l = all (\w -&gt; all (not . isSpace) w &amp;&amp; w /= []) l </span><br><span class="line">                    ==&gt; words (unwords l) == l</span><br></pre></td></tr></table></figure>

<h3 id="PBT-vs-Unit-Testing"><a href="#PBT-vs-Unit-Testing" class="headerlink" title="PBT vs. Unit Testing"></a>PBT vs. Unit Testing</h3><ul>
<li><p>Properties are more compact than unit tests, and describe more cases.</p>
<p>⇒ <strong>Less testing code</strong></p>
</li>
<li><p>Property-based testing heavily depends on <strong>test data generation</strong>:</p>
<ul>
<li><p>Random inputs may not be as informative as hand-crafted inputs</p>
<p>⇒ <strong>use shrinking</strong>(When a test fails, it finds the smallest test case still falls)</p>
</li>
<li><p>Random inputs may not cover all necessary corner cases:</p>
<p>⇒ use a <strong>coverage checker</strong></p>
</li>
<li><p>Random inputs must be generated for user-defined types:</p>
<p>⇒ QuickCheck includes functions to build <strong>custom generators</strong></p>
</li>
</ul>
</li>
<li><p>By increasing the number of random inputs, we improve code coverage in PBT.</p>
</li>
</ul>
<h3 id="Test-Data-Generation"><a href="#Test-Data-Generation" class="headerlink" title="Test Data Generation"></a>Test Data Generation</h3><p>Data which can be generated randomly is represented by the following type class:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arbitrary</span> a <span class="keyword">where</span></span></span><br><span class="line">  arbitrary :: <span class="type">Gen</span> a <span class="comment">-- more on this later</span></span><br><span class="line">  shrink :: a -&gt; [a]</span><br></pre></td></tr></table></figure>

<p>Most of the types we have seen so far implement Arbitrary.</p>
<blockquote>
<p>Shrinking</p>
<p>The shrink function is for when test cases fail. If a given input x fails, QuickCheck will try all inputs in shrink x; repeating the process until the smallest possible input is found</p>
</blockquote>
<h3 id="Testable-Types"><a href="#Testable-Types" class="headerlink" title="Testable Types"></a>Testable Types</h3><p>The type of the quickCheck function is:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- more on IO later</span></span><br><span class="line"><span class="title">quickCheck</span> :: (<span class="type">Testable</span> a) =&gt; a -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>

<p>The Testable type class is the class of things that can be converted into properties. This includes:</p>
<ul>
<li><p>Bool values</p>
</li>
<li><p>QuickCheck’s built-in Property type</p>
</li>
<li><p>Any function from an Arbitrary input to a Testable output:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Arbitrary</span> <span class="title">i</span>, <span class="type">Testable</span> <span class="title">o</span>)</span></span><br><span class="line"><span class="class">      =&gt; <span class="type">Testable</span> (<span class="title">i</span> -&gt; <span class="title">o</span>) ...</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Thus the type [Int] -&gt; [Int] -&gt; Bool (as used earlier) is Testable.</p>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">split</span> :: [a] -&gt; ([a],[a])</span><br><span class="line"><span class="title">split</span> [] = ([],[])</span><br><span class="line"><span class="title">split</span> [a] = ([a],[])</span><br><span class="line"><span class="title">split</span> (x:y:xs) = <span class="keyword">let</span> (l,r) = split xs</span><br><span class="line">                  <span class="keyword">in</span> (x:l,y:r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">prop_splitPerm</span> xs = <span class="keyword">let</span> (l,r) = split (xs :: [<span class="type">Int</span>])</span><br><span class="line">                     <span class="keyword">in</span> permutation xs (l ++ r)</span><br><span class="line"></span><br><span class="line"><span class="title">permutation</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">permutation</span> xs ys = sort xs == sort ys</span><br><span class="line"></span><br><span class="line"><span class="title">permutation'</span> :: (<span class="type">Eq</span> a) =&gt; [a] -&gt; [a] -&gt; (a -&gt; <span class="type">Bool</span>)</span><br><span class="line"><span class="title">permutation'</span> xs ys = \x -&gt; count x xs == count x ys</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    count x l = length (filter (== x) l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">merge</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">merge</span> [] ys = ys</span><br><span class="line"><span class="title">merge</span> xs [] = xs</span><br><span class="line"><span class="title">merge</span> (x:xs) (y:ys) | x &lt;= y    = x : merge xs (y:ys)</span><br><span class="line">                    | otherwise = y : merge (x:xs) ys</span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergePerm</span> xs ys = permutation (xs ++ (ys :: [<span class="type">Int</span>] )) (merge xs ys)</span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergeSorted</span> (<span class="type">Ordered</span> xs) (<span class="type">Ordered</span> ys) = sorted (merge (xs :: [<span class="type">Int</span>]) ys)</span><br><span class="line"></span><br><span class="line"><span class="title">sorted</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">sorted</span> [] = <span class="type">True</span> </span><br><span class="line"><span class="title">sorted</span> [x] = <span class="type">True</span></span><br><span class="line"><span class="title">sorted</span> (x:y:xs) = x &lt;= y &amp;&amp; sorted (y:xs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mergeSort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mergeSort</span> [] = []</span><br><span class="line"><span class="title">mergeSort</span> [x] = [x]</span><br><span class="line"><span class="title">mergeSort</span> xs = <span class="keyword">let</span> (l,r) = split xs</span><br><span class="line">                <span class="keyword">in</span> merge (mergeSort l) (mergeSort r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergeSortSorts</span> xs = sorted (mergeSort (xs :: [<span class="type">Int</span>])) </span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergeSortPerm</span> xs = permutation xs (mergeSort (xs :: [<span class="type">Int</span>]))</span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergeSortExtra</span> xs = mergeSort (xs :: [<span class="type">Int</span>]) == sort xs</span><br><span class="line"></span><br><span class="line"><span class="title">prop_mergeSortUnit</span> = mergeSort [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  quickCheck prop_mergeSortUnit</span><br><span class="line">  quickCheck prop_mergeSortSorts</span><br><span class="line">  quickCheck prop_mergeSortPerm</span><br></pre></td></tr></table></figure>

<h3 id="Redundant-Properties"><a href="#Redundant-Properties" class="headerlink" title="Redundant Properties"></a>Redundant Properties</h3><p>Some properties are technically <strong>redundant</strong> (i.e. implied by other properties in the specification), but there is some value in testing them anyway:</p>
<ul>
<li>They may be <strong>more efficient</strong> than full functional correctness tests, consuming less computing resources to test.</li>
<li>They may be more <strong>fine-grained</strong> to give better test coverage than random inputs for full functional correctness tests.</li>
<li>They provide a good <strong>sanity check</strong> to the full functional correctness properties.</li>
<li>Sometimes full functional correctness is <strong>not easily computable</strong> but tests of weaker properties are.</li>
</ul>
<p>These redundant properties include unit tests. We can (and should) combine both approaches!</p>
<h1 id="Lazy-Evaluation"><a href="#Lazy-Evaluation" class="headerlink" title="Lazy Evaluation"></a>Lazy Evaluation</h1><blockquote>
<p>It never evaluate anything unless it has to</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumTo</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumTo</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">sumTo</span> n = sumTo (n<span class="number">-1</span>) + n</span><br></pre></td></tr></table></figure>

<p>This crashes when given a large number. Why? Because of the growing stack frame.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumTo'</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumTo'</span> a <span class="number">0</span> = a</span><br><span class="line"><span class="title">sumTo'</span> a n = sumTo' (a+n) (n<span class="number">-1</span>)</span><br><span class="line"><span class="title">sumTo</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumTo</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">sumTo</span> n = sumTo (n<span class="number">-1</span>) + n</span><br><span class="line"><span class="comment">-- sumTo' 0 5</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5) (5-1)</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5) 4</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5+4) (4-1)</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5+4) 3</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5+4+3) (3-1)</span></span><br><span class="line"><span class="comment">-- sumTo' (0+5+4+3) 2 -&gt; never evaluate the first argument</span></span><br><span class="line"><span class="comment">-- ..</span></span><br></pre></td></tr></table></figure>

<p>This still crashes when given a large number. Why?</p>
<blockquote>
<p>This is called a space leak, and is one of the main drawbacks of Haskell’s lazy evaluation method.</p>
</blockquote>
<p>Haskell is <strong>lazily evaluated</strong>, also called <strong>call-by-need</strong>.</p>
<p>This means that expressions are only evaluated when they are needed to compute a result for the user. </p>
<p>We can force the previous program to evaluate its accumulator by using a bang pattern, or the primitive operation seq:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE BangPatterns #-&#125;</span></span><br><span class="line"><span class="title">sumTo'</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumTo'</span> !a <span class="number">0</span> = a</span><br><span class="line"><span class="title">sumTo'</span> !a n = sumTo' (a+n) (n<span class="number">-1</span>)</span><br><span class="line"><span class="title">sumTo'</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumTo'</span> a <span class="number">0</span> = a</span><br><span class="line"><span class="title">sumTo'</span> a n = <span class="keyword">let</span> a' = a + n <span class="keyword">in</span> a' `seq` sumTo' a' (n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><p>Lazy Evaluation has many advantages:</p>
<ul>
<li>It enables <strong>equational reasoning</strong> even in the presence of partial functions and non-termination</li>
<li>It allows functions to be <strong>decomposed</strong> without sacrificing efficiency, for example: minimum = head . sort is, depending on sorting algorithm, possibly O(n).</li>
<li>It allows for <strong>circular programming</strong> and <strong>infinite data structures</strong>, which allow us to express more things as <strong>pure functions</strong>.</li>
</ul>
<h2 id="Infinite-Data-Structures"><a href="#Infinite-Data-Structures" class="headerlink" title="Infinite Data Structures"></a>Infinite Data Structures</h2><p>Laziness lets us define data structures that extend infinitely. Lists are a common example, but it also applies to trees or any user-defined data type:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ones</span> = <span class="number">1</span> : ones</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Many functions such as take, drop, head, tail, filter and map work fine on infinite lists.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">naturals</span> = <span class="number">0</span> : map (<span class="number">1</span>+) naturals</span><br><span class="line"><span class="comment">--or</span></span><br><span class="line"><span class="title">naturals</span> = map sum (inits ones)</span><br><span class="line"><span class="comment">--  fibonacci numbers</span></span><br><span class="line"><span class="title">fibs</span> = <span class="number">1</span>:<span class="number">1</span>:zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>



<h1 id="Data-Invariants-and-ADTs"><a href="#Data-Invariants-and-ADTs" class="headerlink" title="Data Invariants and ADTs"></a>Data Invariants and ADTs</h1><h2 id="Structure-of-a-Module"><a href="#Structure-of-a-Module" class="headerlink" title="Structure of a Module"></a>Structure of a Module</h2><p>A Haskell program will usually be made up of many modules, each of which exports one or more data types.</p>
<p>Typically a module for a data type X will also provide a set of functions, called operations, on X.</p>
<ul>
<li>to construct the data type: c :: · · · → X</li>
<li>to query information from the data type: q :: X → · · ·</li>
<li>to update the data type: u :: · · · X → X</li>
</ul>
<p>A lot of software can be designed with this structure.</p>
<p><strong>Example:</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Dictionary</span><br><span class="line">  ( <span class="type">Word</span></span><br><span class="line">  , <span class="type">Definition</span></span><br><span class="line">  , <span class="type">Dict</span></span><br><span class="line">  , <span class="title">emptyDict</span></span><br><span class="line">  , <span class="title">insertWord</span></span><br><span class="line">  , <span class="title">lookup</span></span><br><span class="line">  ) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="type">Word</span>, <span class="title">lookup</span>)</span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck.Modifiers</span><br><span class="line"><span class="comment">-- lookup :: [(a,b)] -&gt; a -&gt; Maybe b</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Word</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Definition</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Dict</span> = <span class="type">D</span> [<span class="type">DictEntry</span>]</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">emptyDict</span> :: <span class="type">Dict</span></span><br><span class="line"><span class="title">emptyDict</span> = <span class="type">D</span> []</span><br><span class="line"></span><br><span class="line"><span class="title">insertWord</span> :: <span class="type">Word</span> -&gt; <span class="type">Definition</span> -&gt; <span class="type">Dict</span> -&gt; <span class="type">Dict</span></span><br><span class="line"><span class="title">insertWord</span> w def (<span class="type">D</span> defs) = <span class="type">D</span> (insertEntry (<span class="type">Entry</span> w def) defs)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    insertEntry wd (x:xs) = <span class="keyword">case</span> compare (word wd) (word x)</span><br><span class="line">                              <span class="keyword">of</span> <span class="type">GT</span> -&gt; x : (insertEntry wd xs)</span><br><span class="line">                                 <span class="type">EQ</span> -&gt; wd : xs</span><br><span class="line">                                 <span class="type">LT</span> -&gt; wd : x : xs</span><br><span class="line">    insertEntry wd [] = [wd]</span><br><span class="line"></span><br><span class="line"><span class="title">lookup</span> :: <span class="type">Word</span> -&gt; <span class="type">Dict</span> -&gt; <span class="type">Maybe</span> <span class="type">Definition</span></span><br><span class="line"><span class="title">lookup</span> w (<span class="type">D</span> es) = search w es</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    search w [] = <span class="type">Nothing</span></span><br><span class="line">    search w (e:es) = <span class="keyword">case</span> compare w (word e) <span class="keyword">of</span></span><br><span class="line">       <span class="type">LT</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">       <span class="type">EQ</span> -&gt; <span class="type">Just</span> (defn e)</span><br><span class="line">       <span class="type">GT</span> -&gt; search w es</span><br><span class="line"></span><br><span class="line"><span class="title">sorted</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">sorted</span> []  = <span class="type">True</span></span><br><span class="line"><span class="title">sorted</span> [x] = <span class="type">True</span></span><br><span class="line"><span class="title">sorted</span> (x:y:xs) = x &lt;= y &amp;&amp; sorted (y:xs)</span><br><span class="line"></span><br><span class="line"><span class="title">wellformed</span> :: <span class="type">Dict</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">wellformed</span> (<span class="type">D</span> es) = sorted es</span><br><span class="line"></span><br><span class="line"><span class="title">prop_insert_wf</span> dict w d = wellformed dict ==&gt;</span><br><span class="line">                          wellformed (insertWord w d dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">DictEntry</span></span></span><br><span class="line">  = <span class="type">Entry</span> &#123; word :: <span class="type">Word</span></span><br><span class="line">          , defn :: <span class="type">Definition</span></span><br><span class="line">          &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Ord</span> <span class="type">DictEntry</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="type">Entry</span> w1 d1 &lt;= <span class="type">Entry</span> w2 d2 = w1 &lt;= w2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">DictEntry</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="type">Entry</span> &lt;$&gt; arbitrary &lt;*&gt; arbitrary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">Dict</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="keyword">do</span></span><br><span class="line">    <span class="type">Ordered</span> ds &lt;- arbitrary</span><br><span class="line">    pure (<span class="type">D</span> ds)</span><br><span class="line"></span><br><span class="line"><span class="title">prop_arbitrary_wf</span> dict = wellformed dict</span><br></pre></td></tr></table></figure>

<h2 id="Data-Invariants"><a href="#Data-Invariants" class="headerlink" title="Data Invariants"></a>Data Invariants</h2><blockquote>
<p>Data invariants are properties that pertain to a particular data type. Whenever we use operations on that data type, we want to know that our data invariants are maintained.</p>
</blockquote>
<p>For a given data type X, we define a wellformedness predicate</p>
<p>$$<br>\text{wf :: X → Bool}<br>$$<br>For a given value x :: X, wf x returns true iff our data invariants hold for the value x</p>
<blockquote>
<p>For each operation, if all input values of type X satisfy wf, all output values will satisfy wf.</p>
<p>In other words, for each constructor operation c :: · · · → X, we must show wf (c · · ·), and for each update operation u :: X → X we must show wf x =⇒ wf(u x)</p>
</blockquote>
<h2 id="Abstract-Data-Types"><a href="#Abstract-Data-Types" class="headerlink" title="Abstract Data Types"></a>Abstract Data Types</h2><blockquote>
<p>An abstract data type (ADT) is a data type where the implementation details of the type and its associated operations are hidden.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Dict</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Word</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Definition</span> = <span class="type">String</span></span></span><br><span class="line"><span class="title">emptyDict</span>  :: <span class="type">Dict</span></span><br><span class="line"><span class="title">insertWord</span> :: <span class="type">Word</span> -&gt; <span class="type">Definition</span> -&gt; <span class="type">Dict</span> -&gt; <span class="type">Dict</span></span><br><span class="line"><span class="title">lookup</span>     :: <span class="type">Word</span> -&gt; <span class="type">Dict</span> -&gt; <span class="type">Maybe</span> <span class="type">Definition</span></span><br></pre></td></tr></table></figure>

<p>If we don’t have access to the implementation of Dict, then we can only access it via the provided operations, which we know preserve our data invariants. Thus, our data invariants cannot be violated if this module is correct.</p>
<p>In general, <strong>abstraction</strong> is the process of <strong>eliminating detail</strong>.</p>
<p>The inverse of abstraction is called <strong>refinement</strong>.</p>
<p>Abstract data types like the dictionary above are <strong>abstract</strong> in the sense that their implementation details are hidden, and we no longer have to reason about them on the level of implementation.</p>
<h2 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h2><p>Suppose we had a sendEmail function</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sendEmail</span> :: <span class="type">String</span> <span class="comment">-- email address</span></span><br><span class="line">          -&gt; <span class="type">String</span> <span class="comment">-- message</span></span><br><span class="line">          -&gt; <span class="type">IO</span> () <span class="comment">-- action (more in 2 wks)</span></span><br></pre></td></tr></table></figure>

<p>It is possible to mix the two String arguments, and even if we get the order right, it’s possible that the given email address is not valid.</p>
<p>We could define a tiny ADT for validated email addresses, where the data invariant is that the contained email address is valid:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> EmailADT(<span class="type">Email</span>, <span class="title">checkEmail</span>, <span class="title">sendEmail</span>)</span><br><span class="line">    newtype Email = Email String</span><br><span class="line">    checkEmail :: String -&gt; Maybe Email</span><br><span class="line">    checkEmail str | '@' `elem` str = Just (<span class="type">Email</span> <span class="title">str</span>)</span><br><span class="line">                   | otherwise      = Nothing</span><br><span class="line"><span class="comment">-- Then, change the type of sendEmail:</span></span><br><span class="line">    sendEmail :: Email -&gt; String -&gt; IO()</span><br></pre></td></tr></table></figure>

<p>The only way (outside of the EmailADT module) to create a value of type Email is to use checkEmail. </p>
<p>checkEmail is an example of what we call a <strong>smart constructo</strong>r: a constructor that enforces data invariants.</p>
<h1 id="Data-Refinement"><a href="#Data-Refinement" class="headerlink" title="Data Refinement"></a>Data Refinement</h1><h2 id="Reasoning-about-ADTs"><a href="#Reasoning-about-ADTs" class="headerlink" title="Reasoning about ADTs"></a>Reasoning about ADTs</h2><p>Consider the following, more traditional example of an ADT interface, the unbounded queue:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Queue</span></span></span><br><span class="line"><span class="title">emptyQueue</span> :: <span class="type">Queue</span></span><br><span class="line"><span class="title">enqueue</span> :: <span class="type">Int</span> -&gt; <span class="type">Queue</span> -&gt; <span class="type">Queue</span></span><br><span class="line"><span class="title">front</span>   :: <span class="type">Queue</span> -&gt; <span class="type">Int</span> <span class="comment">-- partial</span></span><br><span class="line"><span class="title">dequeue</span> :: <span class="type">Queue</span> -&gt; <span class="type">Queue</span> <span class="comment">-- partial</span></span><br><span class="line"><span class="title">size</span>    :: <span class="type">Queue</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>

<p>We could try to come up with properties that relate these functions to each other without reference to their implementation, such as:</p>
<p>dequeue (enqueue x emptyQueue) == emptyQueue</p>
<p>However these do not capture functional correctness (usually).</p>
<h2 id="Models-for-ADTs"><a href="#Models-for-ADTs" class="headerlink" title="Models for ADTs"></a>Models for ADTs</h2><p>We could imagine a simple implementation for queues, just in terms of lists:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">emptyQueueL</span> = []</span><br><span class="line"><span class="title">enqueueL</span> a  = (++ [a])</span><br><span class="line"><span class="title">frontL</span>      = head</span><br><span class="line"><span class="title">dequeueL</span>    = tail</span><br><span class="line"><span class="title">sizeL</span>       = length</span><br></pre></td></tr></table></figure>

<p>But this implementation is O(n) to enqueue! Unacceptable!</p>
<p><strong>However!</strong>(This is out mental model)</p>
<p>This is a dead simple implementation, and trivial to see that it is correct. If we make a better queue implementation, it should always give the same results as this simple one. Therefore: This implementation serves as a <strong>functional correctness specification</strong> for our Queue type!</p>
<h2 id="Refinement-Relations"><a href="#Refinement-Relations" class="headerlink" title="Refinement Relations"></a>Refinement Relations</h2><blockquote>
<p>The typical approach to connect our model queue to our Queue type is to define a relation, called a <strong>refinement relation</strong>, that relates a Queue to a list and tells us if the two structures represent the same queue conceptually:</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rel</span> :: <span class="type">Queue</span> -&gt; [<span class="type">Int</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">prop_empty_r</span> = rel emptyQueue emptyQueueL</span><br><span class="line"><span class="title">prop_size_r</span> fq lq = rel fq lq ==&gt; size fq == sizeL lq</span><br><span class="line"><span class="title">prop_enq_ref</span> fq lq x = rel fq lq ==&gt; rel (enqueue x fq) (enqueueL x lq)</span><br></pre></td></tr></table></figure>

<h2 id="Abstraction-Functions"><a href="#Abstraction-Functions" class="headerlink" title="Abstraction Functions"></a>Abstraction Functions</h2><p>These refinement relations are very difficult to use with QuickCheck because the rel fq lq preconditions are very hard to satisfy with randomly generated inputs. For this example, it’s a lot easier if we define an abstraction function that computes the corresponding <strong>abstract</strong> list from the <strong>concrete</strong> Queue.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">toAbstract</span> :: <span class="type">Queue</span> → [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>

<p>Conceptually, our refinement relation is then just:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\fq lq → absfun fq == lq</span><br></pre></td></tr></table></figure>

<p>However, we can re-express our properties in a much more QC-friendly format</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">emptyQueueL</span> = []</span><br><span class="line"><span class="title">enqueueL</span> a  = (++ [a])</span><br><span class="line"><span class="title">frontL</span>      = head</span><br><span class="line"><span class="title">dequeueL</span>    = tail</span><br><span class="line"><span class="title">sizeL</span>       = length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">toAbstract</span> :: <span class="type">Queue</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">toAbstract</span> (<span class="type">Q</span> f sf r sr) = f ++ reverse r</span><br><span class="line"></span><br><span class="line"><span class="title">prop_empty_ref</span> = toAbstract emptyQueue == emptyQueueL</span><br><span class="line"></span><br><span class="line"><span class="title">prop_enqueue_ref</span> fq x = toAbstract (enqueue x fq)</span><br><span class="line">                     == enqueueL x (toAbstract fq)</span><br><span class="line"></span><br><span class="line"><span class="title">prop_size_ref</span> fq = size fq == sizeL (toAbstract fq)</span><br><span class="line"></span><br><span class="line"><span class="title">prop_front_ref</span> fq = size fq &gt; <span class="number">0</span> ==&gt; front fq == frontL (toAbstract fq)</span><br><span class="line"><span class="title">prop_deq_ref</span> fq = size fq &gt; <span class="number">0</span> ==&gt;  toAbstract (dequeue fq)</span><br><span class="line">                                == dequeueL (toAbstract fq)</span><br><span class="line"></span><br><span class="line"><span class="title">prop_wf_empty</span> = wellformed emptyQueue</span><br><span class="line"><span class="title">prop_wf_enq</span> x q = wellformed q ==&gt; wellformed (enqueue x q)</span><br><span class="line"><span class="title">prop_wf_deq</span> x q = wellformed q &amp;&amp; size q &gt; <span class="number">0</span> ==&gt; wellformed (dequeue q)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Queue</span> = <span class="type">Q</span> [<span class="type">Int</span>] <span class="comment">-- front of the queue</span></span></span><br><span class="line">               <span class="type">Int</span>   <span class="comment">-- size of the front</span></span><br><span class="line">               [<span class="type">Int</span>] <span class="comment">-- rear of the queue</span></span><br><span class="line">               <span class="type">Int</span>   <span class="comment">-- size of the rear</span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">wellformed</span> :: <span class="type">Queue</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">wellformed</span> (<span class="type">Q</span> f sf r sr) = length f == sf &amp;&amp; length r == sr</span><br><span class="line">                        &amp;&amp; sf &gt;= sr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">Queue</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="keyword">do</span></span><br><span class="line">    <span class="type">NonNegative</span> sf' &lt;- arbitrary</span><br><span class="line">    <span class="type">NonNegative</span> sr &lt;- arbitrary</span><br><span class="line">    <span class="keyword">let</span> sf = sf' + sr</span><br><span class="line">    f &lt;- vectorOf sf arbitrary</span><br><span class="line">    r &lt;- vectorOf sr arbitrary</span><br><span class="line">    pure (<span class="type">Q</span> f sf r sr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">inv3</span> :: <span class="type">Queue</span> -&gt; <span class="type">Queue</span></span><br><span class="line"><span class="title">inv3</span> (<span class="type">Q</span> f sf r sr)</span><br><span class="line">   | sf &lt; sr   = <span class="type">Q</span> (f ++ reverse r) (sf + sr) [] <span class="number">0</span></span><br><span class="line">   | otherwise = <span class="type">Q</span> f sf r sr</span><br><span class="line"></span><br><span class="line"><span class="title">emptyQueue</span> :: <span class="type">Queue</span></span><br><span class="line"><span class="title">emptyQueue</span> = <span class="type">Q</span> [] <span class="number">0</span> [] <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">enqueue</span> :: <span class="type">Int</span> -&gt; <span class="type">Queue</span> -&gt; <span class="type">Queue</span></span><br><span class="line"><span class="title">enqueue</span> x (<span class="type">Q</span> f sf r sr) = inv3 (<span class="type">Q</span> f sf (x:r) (sr+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">front</span> :: <span class="type">Queue</span> -&gt; <span class="type">Int</span>   <span class="comment">-- partial</span></span><br><span class="line"><span class="title">front</span> (<span class="type">Q</span> (x:f) sf r sr) = x</span><br><span class="line"></span><br><span class="line"><span class="title">dequeue</span> :: <span class="type">Queue</span> -&gt; <span class="type">Queue</span> <span class="comment">-- partial</span></span><br><span class="line"><span class="title">dequeue</span> (<span class="type">Q</span> (x:f) sf r sr) = inv3 (<span class="type">Q</span> f (sf <span class="number">-1</span>) r sr)</span><br><span class="line"></span><br><span class="line"><span class="title">size</span>    :: <span class="type">Queue</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">size</span> (<span class="type">Q</span> f sf r sr) = sf + sr</span><br></pre></td></tr></table></figure>

<h2 id="Data-Refinement-1"><a href="#Data-Refinement-1" class="headerlink" title="Data Refinement"></a>Data Refinement</h2><p>These kinds of properties establish what is known as a <strong><em>data refinement</em></strong> from the <strong>abstract</strong>, slow, list model to the fast, <strong>concrete</strong> Queue implementation.</p>
<p><strong>Refinement and Specifications</strong></p>
<p>In general, all <strong>functional correctness specifications</strong> can be expressed as:</p>
<ul>
<li>all data invariants are maintained, and</li>
<li>the implementation is a refinement of an abstract correctness model.</li>
</ul>
<p>There is a limit to the amount of abstraction we can do before they become useless for testing (but not necessarily for proving).</p>
<h1 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h1><blockquote>
<p>Effects are observable phenomena from the execution of a program.</p>
</blockquote>
<h2 id="Internal-vs-External-Effects"><a href="#Internal-vs-External-Effects" class="headerlink" title="Internal vs. External Effects"></a>Internal vs. External Effects</h2><p><strong>External Observability</strong></p>
<blockquote>
<p>An external effect is an effect that is observable outside the function. Internal effects are not observable from outside.</p>
<p><strong>Example</strong></p>
<p>Console, file and network I/O; termination and non-termination; non-local control flow; etc.</p>
</blockquote>
<p>Are memory effects external or internal?</p>
<p>Depends on the scope of the memory being accessed. Global variable accesses are external.</p>
<h2 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h2><p>A function with no external effects is called a pure function.</p>
<blockquote>
<p>A pure function is the mathematical notion of a function. That is, a function of type a -&gt; b is fully specified by a mapping from all elements of the domain type a to the codomain type b.</p>
</blockquote>
<p>Consequences: </p>
<ul>
<li>Two invocations with the same arguments result in the same value. </li>
<li>No observable trace is left beyond the result of the function. </li>
<li>No implicit notion of time or order of execution.</li>
</ul>
<h2 id="Haskell-Functions"><a href="#Haskell-Functions" class="headerlink" title="Haskell Functions"></a>Haskell Functions</h2><p>Haskell functions are technically not pure.</p>
<ul>
<li><p>They can loop infinitely.</p>
</li>
<li><p>They can throw exceptions (<strong>partial functions</strong>)</p>
</li>
<li><p>They can force evaluation of unevaluated expressions.</p>
</li>
</ul>
<blockquote>
<p><strong>Caveat</strong></p>
<p>Purity only applies to a particular level of abstraction. Even ignoring the above, assembly instructions produced by GHC aren’t really pure.</p>
</blockquote>
<p>Despite the impurity of Haskell functions, we can often reason as though they are pure. Hence we call Haskell a purely functional language.</p>
<h3 id="The-Danger-of-Implicit-Side-Effects"><a href="#The-Danger-of-Implicit-Side-Effects" class="headerlink" title="The Danger of Implicit Side Effects"></a>The Danger of Implicit Side Effects</h3><ul>
<li>They introduce (often subtle) requirements on the evaluation order.</li>
<li>They are not visible from the type signature of the function. </li>
<li>They introduce <strong>non-local</strong> dependencies which is bad for software design, increasing <strong>coupling</strong>.</li>
<li>They interfere badly with strong typing, for example mutable arrays in Java, or reference types in ML.</li>
</ul>
<p>We can’t, in general, <strong>reason equationally</strong> about effectful programs!</p>
<h3 id="Can-we-program-with-pure-functions"><a href="#Can-we-program-with-pure-functions" class="headerlink" title="Can we program with pure functions?"></a>Can we program with pure functions?</h3><p>Typically, a computation involving some state of type s and returning a result of type a can be expressed as a function:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">s</span> -&gt; (s, a)</span><br></pre></td></tr></table></figure>

<p>Rather than change the state, we return a new copy of the state.</p>
<blockquote>
<p>All that copying might seem expensive, but by using tree data structures, we can usually reduce the cost to an O(log n) overhead.</p>
</blockquote>
<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><h2 id="State-Passing"><a href="#State-Passing" class="headerlink" title="State Passing"></a>State Passing</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Branch</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) | <span class="type">Leaf</span></span></span><br><span class="line"><span class="comment">-- Given a tree, label each node with an ascending number in infix order:</span></span><br><span class="line"><span class="title">label</span> :: <span class="type">Tree</span> () -&gt; <span class="type">Tree</span> <span class="type">Int</span></span><br><span class="line"><span class="title">lable</span> t = snd (go t <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">where</span> </span><br><span class="line">		go :: <span class="type">Tree</span>() -&gt; <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line">		go <span class="type">Leaf</span> c = (c, <span class="type">Leaf</span>)</span><br><span class="line">		go (<span class="type">Branch</span> () l r) c = <span class="keyword">let</span></span><br><span class="line">        (c', l') = go l c</span><br><span class="line">        v = c'</span><br><span class="line">        (c'', r') = go r (c'+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">in</span> (c'', <span class="type">Branch</span> v l' r')</span><br><span class="line"><span class="comment">-- it works but not pretty</span></span><br></pre></td></tr></table></figure>

<p>Let’s use a data type to simplify this!</p>
<h2 id="State-1"><a href="#State-1" class="headerlink" title="State"></a>State</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">State</span> s a = <span class="type">A</span> procedure that, manipulating some state of <span class="keyword">type</span> s, returns a</span></span><br><span class="line"><span class="comment">-- State Operations</span></span><br><span class="line"><span class="title">get</span> :: <span class="type">State</span> s s</span><br><span class="line"><span class="title">put</span> :: s -&gt; <span class="type">State</span> s ()</span><br><span class="line"><span class="title">pure</span> :: a -&gt; <span class="type">State</span> s a</span><br><span class="line"><span class="title">evalState</span> :: <span class="type">State</span> s a -&gt; s -&gt; a</span><br><span class="line"><span class="comment">-- Sequential Composition</span></span><br><span class="line"><span class="comment">-- Do one state action after another with do blocks:</span></span><br><span class="line"><span class="title">do</span> put <span class="number">42</span> desugars put <span class="number">42</span> &gt;&gt; put <span class="type">True</span></span><br><span class="line"><span class="title">pure</span> <span class="type">True</span></span><br><span class="line">(&gt;&gt;) :: <span class="type">State</span> s a -&gt; <span class="type">State</span> s b -&gt; <span class="type">State</span> s b</span><br><span class="line"><span class="comment">-- Bind</span></span><br><span class="line"><span class="comment">-- The 2nd step can depend on the first with bind:</span></span><br><span class="line"><span class="title">do</span> x &lt;- get desugars get &gt;&gt;= \x -&gt; pure (x + <span class="number">1</span>)</span><br><span class="line"><span class="title">pure</span> (x+<span class="number">1</span>)</span><br><span class="line">(&gt;&gt;=) :: <span class="type">State</span> s a -&gt; (a -&gt; <span class="type">State</span> s b) -&gt; <span class="type">State</span> s b</span><br></pre></td></tr></table></figure>

<p> <strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">modify :: (s -&gt; s) -&gt; State s ()</span></span><br><span class="line"><span class="comment">modify f = do</span></span><br><span class="line"><span class="comment">  s &lt;- get</span></span><br><span class="line"><span class="comment">  put (f s)</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">label'</span> :: <span class="type">Tree</span> () -&gt; <span class="type">Tree</span> <span class="type">Int</span></span><br><span class="line"><span class="title">label'</span> t = evalState (go t) <span class="number">1</span> </span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go :: <span class="type">Tree</span> () -&gt; <span class="type">State</span> <span class="type">Int</span> (<span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line">    go <span class="type">Leaf</span> = pure <span class="type">Leaf</span></span><br><span class="line">    go (<span class="type">Branch</span> () l r) = <span class="keyword">do</span></span><br><span class="line">       l' &lt;- go l</span><br><span class="line">       v  &lt;- get</span><br><span class="line">       put (v + <span class="number">1</span>)</span><br><span class="line">       r' &lt;- go r</span><br><span class="line">       pure (<span class="type">Branch</span> v l' r')</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">State'</span> s a = <span class="type">State</span> (<span class="title">s</span> -&gt; (<span class="title">s</span>, <span class="title">a</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="title">get'</span> :: <span class="type">State'</span> s s</span><br><span class="line"><span class="title">get'</span> = (<span class="type">State</span> $ \s -&gt; (s, s))  </span><br><span class="line"></span><br><span class="line"><span class="title">put'</span> :: s -&gt; <span class="type">State'</span> s ()</span><br><span class="line"><span class="title">put'</span> s = <span class="type">State</span> $ \_ -&gt; (s,())</span><br><span class="line"></span><br><span class="line"><span class="title">pure'</span> :: a -&gt; <span class="type">State'</span> s a</span><br><span class="line"><span class="title">pure'</span> a = <span class="type">State</span> $ \s -&gt; (s, a)</span><br><span class="line"></span><br><span class="line"><span class="title">evalState'</span> :: <span class="type">State'</span> s a -&gt; s -&gt; a</span><br><span class="line"><span class="title">evalState</span> (<span class="type">State</span> f) s = snd (f s) </span><br><span class="line"></span><br><span class="line">(&gt;&gt;=!) :: <span class="type">State'</span> s a -&gt; (a -&gt; <span class="type">State'</span> s b) -&gt; <span class="type">State'</span> s b</span><br><span class="line">(<span class="type">State</span> c) &gt;&gt;=! f = <span class="type">State</span> $ \s -&gt; <span class="keyword">let</span> (s', a) = c s</span><br><span class="line">                                    (<span class="type">State</span> c') = f a</span><br><span class="line">                                 <span class="keyword">in</span> c' s'</span><br><span class="line"></span><br><span class="line">(&gt;&gt;!) :: <span class="type">State'</span> s a -&gt; <span class="type">State'</span> s b -&gt; <span class="type">State'</span> s b</span><br><span class="line">(&gt;&gt;!) a b = a &gt;&gt;=! \_ -&gt; b</span><br></pre></td></tr></table></figure>

<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>A procedure that performs some side effects, returning a result of type a is written as IO a.</p>
</blockquote>
<p>IO a is an abstract type. But we can think of it as a function:</p>
<p>RealWorld -&gt; (RealWorld, a)</p>
<p>(that’s how it’s implemented in GHC)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: <span class="type">IO</span> a -&gt; (a -&gt; <span class="type">IO</span> b) -&gt; <span class="type">IO</span> b</span><br><span class="line"><span class="title">pure</span>  :: a -&gt; <span class="type">IO</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">getChar</span> :: <span class="type">IO</span> <span class="type">Char</span></span><br><span class="line"><span class="title">readLine</span> :: <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">putStrLn</span> :: <span class="type">String</span> -&gt; <span class="type">IO</span> () <span class="comment">-- return a procedure</span></span><br></pre></td></tr></table></figure>

<h2 id="Infectious-IO"><a href="#Infectious-IO" class="headerlink" title="Infectious IO"></a>Infectious IO</h2><p>We can convert pure values to impure procedures with pure:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span> :: a -&gt; <span class="type">IO</span> a</span><br></pre></td></tr></table></figure>

<p>But we can’t convert impure procedures to pure values</p>
<p>The only function that gets an a from an IO a is &gt;&gt;=:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: <span class="type">IO</span> a -&gt; (a -&gt; <span class="type">IO</span> b) -&gt; <span class="type">IO</span> b</span><br></pre></td></tr></table></figure>

<p>But it returns an IO procedure as well.</p>
<p>If a function makes use of IO effects directly or indirectly, it will have IO in its type!</p>
<h2 id="Haskell-Design-Strategy"><a href="#Haskell-Design-Strategy" class="headerlink" title="Haskell Design Strategy"></a>Haskell Design Strategy</h2><p>We ultimately “run” IO procedures by calling them from main:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/08/06/MLdbBflRi7sHG8e.png" alt="Screen Shot 2020-08-07 at 1.39.29 am.png"></p>
<p><strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Given an input number n, print a triangle of * characters of base width n.</span></span><br><span class="line"><span class="title">printTriangle</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printTriangle</span> <span class="number">0</span> = pure ()</span><br><span class="line"><span class="title">printTriangle</span> n = <span class="keyword">do</span></span><br><span class="line">  putStrLn (replicate n '*')</span><br><span class="line">  printTriangle (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = printTriangle <span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">Design a game that reads in a n × n maze from a file. The player starts at position</span></span><br><span class="line"><span class="comment">(0, 0) and must reach position (n − 1, n − 1) to win. The game accepts keyboard input</span></span><br><span class="line"><span class="comment">to move the player around the maze.</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="keyword">import</span> Data.List </span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">mazeSize</span> :: <span class="type">Int</span> </span><br><span class="line"><span class="title">mazeSize</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tile</span> = <span class="type">Wall</span> | <span class="type">Floor</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Point</span> = (<span class="type">Int</span>, <span class="type">Int</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">lookupMap</span> :: [<span class="type">Tile</span>] -&gt; <span class="type">Point</span> -&gt; <span class="type">Tile</span></span><br><span class="line"><span class="title">lookupMap</span> ts (x,y) = ts !! (y * mazeSize + x)</span><br><span class="line"></span><br><span class="line"><span class="title">addX</span> :: <span class="type">Int</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">Point</span></span><br><span class="line"><span class="title">addX</span> dx (x,y) = (x + dx, y)</span><br><span class="line"></span><br><span class="line"><span class="title">addY</span> :: <span class="type">Int</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">Point</span></span><br><span class="line"><span class="title">addY</span> dy (x,y) = (x, y + dy)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Game</span> = <span class="type">G</span> &#123; <span class="title">player</span> :: <span class="type">Point</span></span></span><br><span class="line"><span class="class">              , <span class="title">map</span>    :: [<span class="type">Tile</span>]</span></span><br><span class="line"><span class="class">              &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">invariant</span> :: <span class="type">Game</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">invariant</span> (<span class="type">G</span> (x,y) ts) = x &gt;= <span class="number">0</span> &amp;&amp; x &lt; mazeSize</span><br><span class="line">                      &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; mazeSize</span><br><span class="line">                      &amp;&amp; lookupMap ts (x,y) /= <span class="type">Wall</span></span><br><span class="line"></span><br><span class="line"><span class="title">moveLeft</span> :: <span class="type">Game</span> -&gt; <span class="type">Game</span> </span><br><span class="line"><span class="title">moveLeft</span> (<span class="type">G</span> p m) </span><br><span class="line">  = <span class="keyword">let</span> g' = <span class="type">G</span> (addX (<span class="number">-1</span>) p) m</span><br><span class="line">     <span class="keyword">in</span> <span class="keyword">if</span> invariant g' <span class="keyword">then</span> g' <span class="keyword">else</span> <span class="type">G</span> p m</span><br><span class="line"></span><br><span class="line"><span class="title">moveRight</span> :: <span class="type">Game</span> -&gt; <span class="type">Game</span></span><br><span class="line"><span class="title">moveRight</span> (<span class="type">G</span> p m) </span><br><span class="line">  = <span class="keyword">let</span> g' = <span class="type">G</span> (addX <span class="number">1</span> p) m</span><br><span class="line">     <span class="keyword">in</span> <span class="keyword">if</span> invariant g' <span class="keyword">then</span> g' <span class="keyword">else</span> <span class="type">G</span> p m</span><br><span class="line"></span><br><span class="line"><span class="title">moveUp</span> :: <span class="type">Game</span> -&gt; <span class="type">Game</span></span><br><span class="line"><span class="title">moveUp</span> (<span class="type">G</span> p m)</span><br><span class="line">  = <span class="keyword">let</span> g' = <span class="type">G</span> (addY (<span class="number">-1</span>) p) m</span><br><span class="line">     <span class="keyword">in</span> <span class="keyword">if</span> invariant g' <span class="keyword">then</span> g' <span class="keyword">else</span> <span class="type">G</span> p m</span><br><span class="line"></span><br><span class="line"><span class="title">moveDown</span> :: <span class="type">Game</span> -&gt; <span class="type">Game</span></span><br><span class="line"><span class="title">moveDown</span> (<span class="type">G</span> p m) </span><br><span class="line">  = <span class="keyword">let</span> g' = <span class="type">G</span> (addY <span class="number">1</span> p) m</span><br><span class="line">     <span class="keyword">in</span> <span class="keyword">if</span> invariant g' <span class="keyword">then</span> g' <span class="keyword">else</span> <span class="type">G</span> p m</span><br><span class="line"></span><br><span class="line"><span class="title">won</span> :: <span class="type">Game</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">won</span> (<span class="type">G</span> p m) = p == (mazeSize<span class="number">-1</span>,mazeSize<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> () </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    str &lt;- readFile <span class="string">"input.txt"</span></span><br><span class="line">    <span class="keyword">let</span> initial = <span class="type">G</span> (<span class="number">0</span>,<span class="number">0</span>) (stringToMap str)</span><br><span class="line">    gameLoop initial</span><br><span class="line">  <span class="keyword">where</span> </span><br><span class="line">    gameLoop :: <span class="type">Game</span> -&gt; <span class="type">IO</span> () </span><br><span class="line">    gameLoop state </span><br><span class="line">        | won state = putStrLn <span class="string">"You win!"</span></span><br><span class="line">        | otherwise = <span class="keyword">do</span> </span><br><span class="line">            display state</span><br><span class="line">            c &lt;- getChar' </span><br><span class="line">            <span class="keyword">case</span> c <span class="keyword">of</span> </span><br><span class="line">                'w' -&gt; gameLoop (moveUp state)</span><br><span class="line">                'a' -&gt; gameLoop (moveLeft state)</span><br><span class="line">                's' -&gt; gameLoop (moveDown state)</span><br><span class="line">                'd' -&gt; gameLoop (moveRight state)</span><br><span class="line">                'q' -&gt; pure ()</span><br><span class="line">                _   -&gt; gameLoop state </span><br><span class="line"></span><br><span class="line"><span class="title">stringToMap</span> :: <span class="type">String</span> -&gt; [<span class="type">Tile</span>]</span><br><span class="line"><span class="title">stringToMap</span> [] = []</span><br><span class="line"><span class="title">stringToMap</span> ('#':xs) = <span class="type">Wall</span> : stringToMap xs </span><br><span class="line"><span class="title">stringToMap</span> (' ':xs) = <span class="type">Floor</span> : stringToMap xs </span><br><span class="line"><span class="title">stringToMap</span> (c:xs)   = stringToMap xs</span><br><span class="line"></span><br><span class="line"><span class="title">display</span> :: <span class="type">Game</span> -&gt; <span class="type">IO</span> () </span><br><span class="line"><span class="title">display</span> (<span class="type">G</span> (px,py) m) = printer (<span class="number">0</span>,<span class="number">0</span>) m </span><br><span class="line">  <span class="keyword">where</span> </span><br><span class="line">    printer (x,y) (t:ts) = <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">if</span> (x,y) == (px,py) <span class="keyword">then</span> putChar '@'</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> t == <span class="type">Wall</span> <span class="keyword">then</span> putChar '#'</span><br><span class="line">        <span class="keyword">else</span> putChar ' '</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == mazeSize - <span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">do</span></span><br><span class="line">            putChar '\n'</span><br><span class="line">            printer (<span class="number">0</span>,y+<span class="number">1</span>) ts </span><br><span class="line">        <span class="keyword">else</span> printer (x+<span class="number">1</span>,y) ts</span><br><span class="line">    printer (x,y) [] = putChar '\n'</span><br><span class="line"></span><br><span class="line"><span class="title">getChar'</span> :: <span class="type">IO</span> <span class="type">Char</span> </span><br><span class="line"><span class="title">getChar'</span> = <span class="keyword">do</span> </span><br><span class="line">    b &lt;- hGetBuffering stdin </span><br><span class="line">    e &lt;- hGetEcho stdin</span><br><span class="line">    hSetBuffering stdin <span class="type">NoBuffering</span></span><br><span class="line">    hSetEcho stdin <span class="type">False</span></span><br><span class="line">    x &lt;- getChar </span><br><span class="line">    hSetBuffering stdin b</span><br><span class="line">    hSetEcho stdin e</span><br><span class="line">    pure x</span><br></pre></td></tr></table></figure>

<h2 id="Benefits-of-an-IO-Type"><a href="#Benefits-of-an-IO-Type" class="headerlink" title="Benefits of an IO Type"></a>Benefits of an IO Type</h2><ul>
<li>Absence of effects makes type system more informative:<ul>
<li>A type signatures captures entire interface of the function</li>
<li>All dependencies are explicit in the form of data dependencies.</li>
<li>All dependencies are typed</li>
</ul>
</li>
<li>It is easier to reason about pure code and it is easier to test<ul>
<li>Testing is local, doesn’t require complex set-up and tear-down.</li>
<li>Reasoning is local, doesn’t require state invariants</li>
<li>Type checking leads to strong guarantees.</li>
</ul>
</li>
</ul>
<h2 id="Mutable-Variables"><a href="#Mutable-Variables" class="headerlink" title="Mutable Variables"></a>Mutable Variables</h2><p>We can have honest-to-goodness mutability in Haskell, if we really need it, using IORef.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IORef</span> a</span></span><br><span class="line"><span class="title">newIORef</span> :: a -&gt; <span class="type">IO</span> (<span class="type">IORef</span> a)</span><br><span class="line"><span class="title">readIORef</span> :: <span class="type">IORef</span> a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">writeIORef</span> :: <span class="type">IORef</span> a -&gt; a -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.IORef </span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck.Monadic </span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"></span><br><span class="line"><span class="title">averageListIO</span> :: [<span class="type">Int</span>] -&gt; <span class="type">IO</span> <span class="type">Int</span></span><br><span class="line"><span class="title">averageListIO</span> ls = <span class="keyword">do</span> </span><br><span class="line">    sum &lt;- newIORef <span class="number">0</span></span><br><span class="line">    count &lt;- newIORef <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> loop :: [<span class="type">Int</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line">        loop [] = pure ()</span><br><span class="line">        loop (x:xs) = <span class="keyword">do</span> </span><br><span class="line">            s &lt;- readIORef sum </span><br><span class="line">            writeIORef sum (s + x) </span><br><span class="line">            c &lt;- readIORef count </span><br><span class="line">            writeIORef count (c + <span class="number">1</span>) </span><br><span class="line">            loop xs </span><br><span class="line">    loop ls </span><br><span class="line">    s &lt;- readIORef sum </span><br><span class="line">    c &lt;- readIORef count </span><br><span class="line">    pure (s `div` c)    </span><br><span class="line"></span><br><span class="line"><span class="title">prop_average</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">prop_average</span> ls = monadicIO $ <span class="keyword">do</span> </span><br><span class="line">    pre (length ls &gt; <span class="number">0</span>)</span><br><span class="line">    avg &lt;- run (averageListIO ls)</span><br><span class="line">    assert (avg == (sum ls `div` length ls))</span><br></pre></td></tr></table></figure>

<h3 id="Mutable-Variables-Locally"><a href="#Mutable-Variables-Locally" class="headerlink" title="Mutable Variables, Locally"></a>Mutable Variables, Locally</h3><p>Something like averaging a list of numbers doesn’t require external effects, even if we use mutation internally.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">STRef</span> s a</span></span><br><span class="line"><span class="title">newSTRef</span> :: a -&gt; <span class="type">ST</span> (<span class="type">STRef</span> s a)</span><br><span class="line"><span class="title">readSTRef</span> :: <span class="type">STRef</span> s a -&gt; <span class="type">ST</span> s a</span><br><span class="line"><span class="title">writeSTRef</span> :: <span class="type">STRef</span> s a -&gt; a -&gt; <span class="type">ST</span> s ()</span><br><span class="line"><span class="title">runST</span> :: (<span class="keyword">forall</span> s. <span class="type">ST</span> s a) -&gt; a</span><br></pre></td></tr></table></figure>

<p>The extra s parameter is called a state thread, that ensures that mutable variables don’t leak outside of the ST computation.</p>
<blockquote>
<p>The ST type is not assessable in this course, but it is useful sometimes in Haskell programming.</p>
</blockquote>
<h2 id="QuickChecking-Effects"><a href="#QuickChecking-Effects" class="headerlink" title="QuickChecking Effects"></a>QuickChecking Effects</h2><p>QuickCheck lets us test IO (and ST) using this special <strong>property monad</strong> interface:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">monadicIO</span> :: <span class="type">PropertyM</span> <span class="type">IO</span> () -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">pre</span>       :: <span class="type">Bool</span> -&gt; <span class="type">PropertyM</span> <span class="type">IO</span> ()</span><br><span class="line"><span class="title">assert</span>    :: <span class="type">Bool</span> -&gt; <span class="type">PropertyM</span> <span class="type">IO</span> ()</span><br><span class="line"><span class="title">run</span>       :: <span class="type">IO</span> a -&gt; <span class="type">PropertyM</span> <span class="type">IO</span> a</span><br></pre></td></tr></table></figure>

<p>Do notation and similar can be used for PropertyM IO procedures just as with State s and IO procedures.</p>
<p><strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- GNU Factor</span></span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck </span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck.Modifiers</span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck.Monadic </span><br><span class="line"><span class="keyword">import</span> System.Process</span><br><span class="line"></span><br><span class="line"><span class="comment">-- readProcess :: FilePath -&gt; [String] -&gt; String -&gt; IO String</span></span><br><span class="line"></span><br><span class="line"><span class="title">test_gnuFactor</span> :: <span class="type">Positive</span> <span class="type">Integer</span> -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">test_gnuFactor</span> (<span class="type">Positive</span> n) = monadicIO $ <span class="keyword">do</span></span><br><span class="line">    str &lt;- run (readProcess <span class="string">"gfactor"</span> [show n] <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">let</span> factors = map read (tail (words str))</span><br><span class="line">    assert (product factors == n)</span><br></pre></td></tr></table></figure>



<h1 id="Functor-1"><a href="#Functor-1" class="headerlink" title="Functor"></a>Functor</h1><p>Recall the type class defined over type constructors called <a href="#functor"><strong>Functor</strong></a>.</p>
<p>We’ve seen instances for lists, Maybe, tuples and functions.</p>
<p>Other instances include: </p>
<ul>
<li>IO (how?) </li>
<li>States (how?) </li>
<li>Gen</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ioMap</span> :: (a -&gt; b) -&gt; <span class="type">IO</span> a -&gt; <span class="type">IO</span> b</span><br><span class="line"><span class="title">ioMap</span> f act = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- act</span><br><span class="line">	pure (f a)</span><br><span class="line">	</span><br><span class="line"><span class="title">stateMap</span> :: (a -&gt; b) -&gt; <span class="type">State</span> s a -&gt; <span class="type">State</span> s b</span><br><span class="line"><span class="title">stateMap</span> f act = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- act</span><br><span class="line">	pure (f a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- more general</span></span><br><span class="line"><span class="title">monadMap</span> :: <span class="type">Monad</span> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</span><br><span class="line"><span class="title">monadMap</span> f act = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- act</span><br><span class="line">	pure (f a)</span><br></pre></td></tr></table></figure>

<h2 id="QuickCheck-Generators"><a href="#QuickCheck-Generators" class="headerlink" title="QuickCheck Generators"></a>QuickCheck Generators</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">class Arbitrary a where</span></span><br><span class="line"><span class="comment">	arbitray :: Gen a</span></span><br><span class="line"><span class="comment">	shrink   :: a -&gt; [a]</span></span><br><span class="line"><span class="comment">-- Gen a ~=~ random generator of values type a.</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">sortedLists</span> :: (<span class="type">Arbitrary</span> a, <span class="type">Ord</span> a) =&gt; <span class="type">Gen</span> [a]</span><br><span class="line"><span class="title">sortedLists</span> = fmap sort arbitrary :: <span class="type">Gen</span> a</span><br><span class="line"><span class="comment">-- listOf :: Gen a -&gt; Gen [a]</span></span><br></pre></td></tr></table></figure>



<h1 id="Applicative-Functors"><a href="#Applicative-Functors" class="headerlink" title="Applicative Functors"></a>Applicative Functors</h1><h2 id="Binary-Functions"><a href="#Binary-Functions" class="headerlink" title="Binary Functions"></a>Binary Functions</h2><p>Suppose we want to look up a student’s zID and program code using these functions:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupID</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">ZID</span></span><br><span class="line"><span class="title">lookupProgram</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">Program</span></span><br><span class="line"><span class="comment">--  we had a function:</span></span><br><span class="line"><span class="title">makeRecord</span> :: <span class="type">ZID</span> -&gt; <span class="type">Program</span> -&gt; <span class="type">StudentRecord</span></span><br></pre></td></tr></table></figure>

<p>How can we combine these functions to get a function of type Name -&gt; Maybe StudentRecord?</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupRecord</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">StudentRecord</span></span><br><span class="line"><span class="title">lookupRecord</span> n = <span class="keyword">let</span> zid     = lookupID n</span><br><span class="line">                     program = lookupProgram n</span><br><span class="line">                 <span class="keyword">in</span> ?</span><br></pre></td></tr></table></figure>

<p><strong>Binary Map?</strong></p>
<p>We could imagine a binary version of the maybeMap function:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maybeMap2</span> :: (a -&gt; b -&gt; c)</span><br><span class="line">          -&gt; <span class="type">Maybe</span> a -&gt; <span class="type">Maybe</span> b -&gt; <span class="type">Maybe</span> c</span><br></pre></td></tr></table></figure>

<p>But then, we might need a trinary version.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maybeMap3</span> :: (a -&gt; b -&gt; c -&gt; d)</span><br><span class="line">          -&gt; <span class="type">Maybe</span> a -&gt; <span class="type">Maybe</span> b -&gt; <span class="type">Maybe</span> c -&gt; <span class="type">Maybe</span> d</span><br></pre></td></tr></table></figure>

<p>Or even a 4-ary version, 5-ary, 6-ary. . . this would quickly become impractical!</p>
<p><strong>Using Functor?</strong></p>
<p>Using fmap gets us part of the way there:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupRecord'</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> (<span class="type">Program</span> -&gt; <span class="type">StudentRecord</span>)</span><br><span class="line"><span class="title">lookupRecord'</span> n = <span class="keyword">let</span> zid     = lookupID n</span><br><span class="line">                      program = lookupProgram n</span><br><span class="line">                  <span class="keyword">in</span> fmap makeRecord zid</span><br><span class="line">                  <span class="comment">-- what about program?</span></span><br></pre></td></tr></table></figure>

<p>But, now we have a function inside a Maybe.</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><blockquote>
<p>This is encapsulated by a subclass of Functor called Applicative.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>

<p>Maybe is an instance, so we can use this for lookupRecord:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupRecord</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">StudentRecord</span></span><br><span class="line"><span class="title">lookupRecord</span> n = <span class="keyword">let</span> zid     = lookupID n</span><br><span class="line">                     program = lookupProgram n</span><br><span class="line">                 <span class="keyword">in</span> fmap makeRecord zid &lt;*&gt; program</span><br><span class="line">                 <span class="comment">-- or pure makeRecord &lt;*&gt; zid &lt;*&gt; program</span></span><br></pre></td></tr></table></figure>

<h3 id="Using-Applicative"><a href="#Using-Applicative" class="headerlink" title="Using Applicative"></a>Using Applicative</h3><p>In general, we can take a regular function application:<br>$$<br>\text{f a b c d}<br>$$<br>And apply that function to Maybe (or other Applicative) arguments using this pattern (where &lt;*&gt; is left-associative):</p>
<p>$$<br>\text{pure f &lt;<em>&gt; ma &lt;</em>&gt; mb &lt;<em>&gt; mc &lt;</em>&gt; }<br>$$</p>
<h3 id="Relationship-to-Functor"><a href="#Relationship-to-Functor" class="headerlink" title="Relationship to Functor"></a>Relationship to Functor</h3><p>All law-abiding instances of Applicative are also instances of Functor, by defining:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> f x = pure f &lt;*&gt; x</span><br></pre></td></tr></table></figure>

<p>Sometimes this is written as an infix operator, &lt;$&gt;, which allows us to write:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span> f &lt;*&gt; ma &lt;*&gt; mb &lt;*&gt; mc &lt;*&gt; md</span><br><span class="line"><span class="comment">-- as:</span></span><br><span class="line"><span class="title">f</span> &lt;$&gt; ma &lt;*&gt; mb &lt;*&gt; mc &lt;*&gt; md</span><br></pre></td></tr></table></figure>

<h3 id="Applicative-laws"><a href="#Applicative-laws" class="headerlink" title="Applicative laws"></a>Applicative laws</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Identity</span></span><br><span class="line"><span class="title">pure</span> id &lt;*&gt; v = v</span><br><span class="line"><span class="comment">-- Homomorphism</span></span><br><span class="line"><span class="title">pure</span> f &lt;*&gt; pure x = pure (f x)</span><br><span class="line"><span class="comment">-- Interchange</span></span><br><span class="line"><span class="title">u</span> &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</span><br><span class="line"><span class="comment">-- Composition</span></span><br><span class="line"><span class="title">pure</span> (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">ZID</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Program</span> = <span class="type">COMP</span> | <span class="type">SENG</span> | <span class="type">BINF</span> | <span class="type">CENG</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">StudentRecord</span> = (<span class="type">Name</span>, <span class="type">ZID</span>, <span class="type">Program</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">lookupID</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">ZID</span></span><br><span class="line"><span class="title">lookupID</span> <span class="string">"Liam"</span> = <span class="type">Just</span> <span class="number">3253158</span></span><br><span class="line"><span class="title">lookupID</span> <span class="string">"Unlucky"</span> = <span class="type">Just</span> <span class="number">4444444</span></span><br><span class="line"><span class="title">lookupID</span> <span class="string">"Prosperous"</span> = <span class="type">Just</span> <span class="number">8888888</span></span><br><span class="line"><span class="title">lookupID</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">lookupProgram</span> :: <span class="type">Name</span> -&gt; <span class="type">Maybe</span> <span class="type">Program</span></span><br><span class="line"><span class="title">lookupProgram</span> <span class="string">"Liam"</span> = <span class="type">Just</span> <span class="type">COMP</span></span><br><span class="line"><span class="title">lookupProgram</span> <span class="string">"Unlucky"</span> = <span class="type">Just</span> <span class="type">SENG</span></span><br><span class="line"><span class="title">lookupProgram</span> <span class="string">"Prosperous"</span> = <span class="type">Just</span> <span class="type">CENG</span></span><br><span class="line"><span class="title">lookupProgram</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">makeRecord</span> :: <span class="type">ZID</span> -&gt; <span class="type">Program</span> -&gt; <span class="type">Name</span> -&gt; <span class="type">StudentRecord</span></span><br><span class="line"><span class="title">makeRecord</span> zid pr name = (name,zid,pr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">liam</span> :: <span class="type">Maybe</span> <span class="type">StudentRecord</span></span><br><span class="line"><span class="title">liam</span> = <span class="keyword">let</span> mzid = lookupID <span class="string">"Liam"</span></span><br><span class="line">           mprg = lookupProgram <span class="string">"Liam"</span></span><br><span class="line">        <span class="keyword">in</span> pure makeRecord &lt;*&gt; mzid &lt;*&gt; mprg &lt;*&gt; pure <span class="string">"Liam"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--     pure :: a -&gt; Maybe a</span></span><br><span class="line"><span class="comment">--     fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws-for-Applicative"><a href="#Functor-Laws-for-Applicative" class="headerlink" title="Functor Laws for Applicative"></a>Functor Laws for Applicative</h3><p>These are proofs not Haskell code:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> f x = pure f &lt;*&gt; x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- The two functor laws are:</span></span><br><span class="line"><span class="number">1.</span> fmap id x == x</span><br><span class="line"><span class="number">2.</span> fmap f (fmap g x) == fmap (f.g) x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Proof:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) pure id &lt;*&gt; x == x <span class="comment">-- true by Identity law</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) pure f &lt;*&gt; (pure g &lt;*&gt; x)</span><br><span class="line">     == pure (.) &lt;*&gt; pure f &lt;*&gt; pure g &lt;*&gt; x <span class="comment">--Composition</span></span><br><span class="line">     == pure ((.) f) &lt;*&gt; pure g &lt;*&gt; x        <span class="comment">--Homomorphism</span></span><br><span class="line">     == pure (f.g) &lt;*&gt; x                     <span class="comment">--Homomorphism</span></span><br></pre></td></tr></table></figure>



<h2 id="Applicative-Lists"><a href="#Applicative-Lists" class="headerlink" title="Applicative Lists"></a>Applicative Lists</h2><p>There are two ways to implement Applicative for lists:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure>

<ul>
<li>Apply each of the given functions to each of the given arguments, concatenating all the results</li>
<li>Apply each function in the list of functions to the corresponding value in the list of arguments</li>
</ul>
<blockquote>
<p>The second one is put behind a newtype (ZipList) in the Haskell standard library.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pureZ</span> :: a -&gt; [a]</span><br><span class="line"><span class="title">pureZ</span> a = a:pureZ a</span><br><span class="line"></span><br><span class="line"><span class="title">applyListsZ</span> :: [a -&gt; b] -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">applyListsZ</span> (f:fs) (x:xs) = f x : applyListsZ fs xs</span><br><span class="line"><span class="title">applyListsZ</span> [] _ = []</span><br><span class="line"><span class="title">applyListsZ</span> _ [] = []</span><br><span class="line"></span><br><span class="line"><span class="title">pureC</span> :: a -&gt; [a]</span><br><span class="line"><span class="title">pureC</span> a = [a] </span><br><span class="line"></span><br><span class="line"><span class="title">applyListsC</span> :: [a -&gt; b] -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">applyListsC</span> (f:fs) args = map f args ++ applyListsC fs args</span><br><span class="line"><span class="title">applyListsC</span> [] args = []</span><br></pre></td></tr></table></figure>

<h3 id="Other-instances"><a href="#Other-instances" class="headerlink" title="Other instances"></a>Other instances</h3><h4 id="QuickCheck-generators-Gen"><a href="#QuickCheck-generators-Gen" class="headerlink" title="QuickCheck generators: Gen"></a>QuickCheck generators: Gen</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Concrete</span> = <span class="type">C</span> [<span class="type">Char</span>] [<span class="type">Char</span>]</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">Concrete</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="type">C</span> &lt;$&gt; arbitrary &lt;*&gt; arbitrary</span><br></pre></td></tr></table></figure>

<h4 id="Functions-gt-x"><a href="#Functions-gt-x" class="headerlink" title="Functions: ((-&gt;) x"></a>Functions: ((-&gt;) x</h4><blockquote>
<p>The <code>Applicative</code> instance for functions lets us pass the same argument into multiple functions without repeating ourselves.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) x) <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; x -&gt; a</span><br><span class="line">  pure a x = a</span><br><span class="line"></span><br><span class="line">  (&lt;*&gt;) :: (x -&gt; (a -&gt; b)) -&gt; (x -&gt; a) -&gt; (x -&gt; b)</span><br><span class="line">  (&lt;*&gt;) xab xa x = xab x (xa x)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- f (g x) (h x) (i x)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Can be written as: </span></span><br><span class="line"><span class="comment">-- (pure f &lt;*&gt; g &lt;*&gt; h &lt;*&gt; i) x</span></span><br></pre></td></tr></table></figure>

<h4 id="Tuples-x"><a href="#Tuples-x" class="headerlink" title="Tuples: ((,) x)"></a>Tuples: ((,) x)</h4><p><strong>We can’t implement pure without an extra constraint!</strong></p>
<blockquote>
<p>The tuple instance for <code>Applicative</code> lets us combine secondary outputs from functions into one secondary output without manually combining them.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) x) <span class="keyword">where</span></span></span><br><span class="line">  fmap :: (a -&gt; b) -&gt; (x,a) -&gt; (x,b)</span><br><span class="line">  fmap f (x,a) = (x,f a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- monoid has an identity element</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> x =&gt; <span class="type">Applicative</span> ((,) x) <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; (x,a)</span><br><span class="line">  pure a = (mempty ,a)</span><br><span class="line"></span><br><span class="line">  (&lt;*&gt;) :: (x,a -&gt; b) -&gt; (x, a) -&gt; (x, b)</span><br><span class="line">  (&lt;*&gt;) (x, f) (x',a) = (x &lt;&gt; x', f a)</span><br></pre></td></tr></table></figure>

<p>It requires <code>Monoid</code> here to combine the values, and to provide a default value for <code>pure</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">A</span> -&gt; (<span class="type">Log</span>, <span class="type">B</span>)</span><br><span class="line"><span class="title">g</span> :: <span class="type">X</span> -&gt; (<span class="type">Log</span>, <span class="type">Y</span>)</span><br><span class="line"><span class="title">a</span> :: <span class="type">A</span></span><br><span class="line"><span class="title">x</span> :: <span class="type">X</span></span><br><span class="line"><span class="title">combine</span> :: <span class="type">B</span> -&gt; <span class="type">Y</span> -&gt; <span class="type">Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- combine the logs silently</span></span><br><span class="line"><span class="title">test</span> :: (<span class="type">Log</span>, <span class="type">Z</span>)</span><br><span class="line"><span class="title">test</span> = combine &lt;$&gt; f a &lt;*&gt; g x</span><br><span class="line"><span class="comment">-- instead of </span></span><br><span class="line"><span class="comment">--  let (l1, b) = f a</span></span><br><span class="line"><span class="comment">--      (l2, y) = g x</span></span><br><span class="line"><span class="comment">--   in (l1 &lt;&gt; l2, combine b y)</span></span><br></pre></td></tr></table></figure>

<h4 id="IO-and-State-s"><a href="#IO-and-State-s" class="headerlink" title="IO and State s"></a>IO and State s</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">	pure :: a -&gt; <span class="type">IO</span> a</span><br><span class="line">	pure a = pure a </span><br><span class="line">	</span><br><span class="line">	(&lt;*&gt;) :: <span class="type">IO</span> (a -&gt; b) -&gt; <span class="type">IO</span> a -&gt; <span class="type">IO</span> b</span><br><span class="line">	pf &lt;*&gt; pa = <span class="keyword">do</span></span><br><span class="line">		f &lt;- pf</span><br><span class="line">		a &lt;- pa</span><br><span class="line">		pure (f a)</span><br></pre></td></tr></table></figure>



<h1 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h1><blockquote>
<p>Monads are types m where we can <strong><em>sequentially compose</em></strong> functions of the form a -&gt; m b</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Sometimes in old documentation the function return is included here, but it is just an alias for pure. It has nothing to do with return as in C/Java/Python etc.</p>
</blockquote>
<p><strong>Example</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Maybe Monad</span></span><br><span class="line">(&gt;&gt;=) :: <span class="type">Maybe</span> a -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; <span class="type">Maybe</span> b</span><br><span class="line">(&gt;&gt;=) <span class="type">Nothing</span> f = <span class="type">Nothing</span></span><br><span class="line">(&gt;&gt;=) (<span class="type">Just</span> a) f = f a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- List Monad</span></span><br><span class="line">(&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]</span><br><span class="line">(&gt;&gt;=) <span class="keyword">as</span> f = concatMap f <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- function</span></span><br><span class="line">(&gt;&gt;=) :: (x -&gt; a) -&gt; (a -&gt; x -&gt;b) -&gt; b</span><br><span class="line">(&gt;&gt;=) xa axb x = axb (xa x) x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- function monad example(reader monad)</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">A</span> -&gt; <span class="type">Config</span> -&gt; <span class="type">B</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">X</span> -&gt; <span class="type">Config</span> -&gt; <span class="type">Y</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">B</span> -&gt; <span class="type">Config</span> -&gt; <span class="type">C</span></span><br><span class="line"></span><br><span class="line"><span class="title">combine</span> :: (<span class="type">A</span>, <span class="type">X</span>) -&gt; <span class="type">Config</span> -&gt; (<span class="type">Y</span>, <span class="type">C</span>)</span><br><span class="line"><span class="title">combine</span> (a, x) = <span class="keyword">do</span></span><br><span class="line">	b &lt;- f a</span><br><span class="line">	y &lt;- g x</span><br><span class="line">	c &lt;- h b</span><br><span class="line">	pure(y, c)</span><br></pre></td></tr></table></figure>



<h2 id="Monad-Law"><a href="#Monad-Law" class="headerlink" title="Monad Law"></a>Monad Law</h2><p>We can define a composition operator with (&gt;&gt;=): </p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;=&lt;) :: (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c) </span><br><span class="line">(f &lt;=&lt; g) x = g x &gt;&gt;= f</span><br></pre></td></tr></table></figure>

<p><strong>Monad Laws</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> &lt;=&lt; (g &lt;=&lt; x) == (f &lt;=&lt; g) &lt;=&lt; x <span class="comment">-- associativity</span></span><br><span class="line"><span class="title">pure</span> &lt;=&lt; f      == f               <span class="comment">-- left identity</span></span><br><span class="line"><span class="title">f</span> &lt;=&lt; pure      == f               <span class="comment">-- right identity</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>These are similar to the monoid laws, generalised for multiple types inside the monad. This sort of structure is called a <strong>category</strong> in mathematics.</p>
</blockquote>
<h2 id="Relationship-to-Applicative"><a href="#Relationship-to-Applicative" class="headerlink" title="Relationship to Applicative"></a>Relationship to Applicative</h2><p>All Monad instances give rise to an Applicative instance, because we can define &lt;*&gt; in terms of &gt;&gt;=.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mf</span> &lt;*&gt; mx = mf &gt;&gt;= \f -&gt; mx &gt;&gt;= \x -&gt; pure (f x)</span><br></pre></td></tr></table></figure>

<p>This implementation is already provided for Monads as the ap function in Control.Monad</p>
<h2 id="Do-notation"><a href="#Do-notation" class="headerlink" title="Do notation"></a>Do notation</h2><p>Working directly with the monad functions can be unpleasant. As we’ve seen, Haskell has some notation to increase niceness:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> x &lt;- y  </span><br><span class="line">									becomes y &gt;&gt;= \x -&gt; <span class="keyword">do</span> z</span><br><span class="line">   z</span><br><span class="line"></span><br><span class="line"><span class="title">do</span> x</span><br><span class="line">                  becomes x &gt;&gt;= \_ -&gt; <span class="keyword">do</span> y</span><br><span class="line">   y</span><br></pre></td></tr></table></figure>

<p><strong>Examples</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment"> (Dice Rolls)</span></span><br><span class="line"><span class="comment"> Roll two 6-sided dice, if the difference is &lt; 2, reroll the second   die. Final score is the</span></span><br><span class="line"><span class="comment"> difference of the two die. What score is most common?</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">roll</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">roll</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">diceGame</span> = <span class="keyword">do</span></span><br><span class="line">	d1 &lt;- roll</span><br><span class="line">	d2 &lt;- roll</span><br><span class="line">	<span class="keyword">if</span> (abs (d1 - d2) &lt; <span class="number">2</span>) <span class="keyword">then</span> <span class="keyword">do</span></span><br><span class="line">		d2' &lt;- roll</span><br><span class="line">		pure (abs (d1 - d2'))</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	  pure (abs (d1 - d2))</span><br><span class="line">	  </span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment"> Partial Functions</span></span><br><span class="line"><span class="comment"> We have a list of student names in a database of type [(ZID, Name)]. Given a list of</span></span><br><span class="line"><span class="comment"> zID’s, return a Maybe [Name], where Nothing indicates that a zID could not be found</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">db</span> :: [(<span class="type">ZID</span>, <span class="type">Name</span>)]</span><br><span class="line"><span class="title">db</span> = [(<span class="number">3253158</span>, <span class="string">"Liam"</span>),</span><br><span class="line">      (<span class="number">8888888</span>, <span class="string">"Rich"</span>),</span><br><span class="line">      (<span class="number">4444444</span>, <span class="string">"Mort"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="title">studentNames</span> :: [<span class="type">ZID</span>] -&gt; <span class="type">Maybe</span> [<span class="type">Name</span>]</span><br><span class="line"><span class="title">studentNames</span> [] = pure []</span><br><span class="line"><span class="title">studentNames</span> (z:zs) = <span class="keyword">do</span> </span><br><span class="line">     n  &lt;- lookup z db</span><br><span class="line">     ns &lt;- studentNames zs</span><br><span class="line">     pure (n:ns)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- briefer but less clear with applicative notation:</span></span><br><span class="line"><span class="comment">-- studentNames (z:zs) = (:) &lt;$&gt; lookup z db &lt;*&gt; studentNames zs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment"> Arbitrary Instances</span></span><br><span class="line"><span class="comment"> Define a Tree type and a generator for search trees:</span></span><br><span class="line"><span class="comment"> searchTrees :: Int -&gt; Int -&gt; Generator Tree</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Leaf</span> </span></span><br><span class="line">            | <span class="type">Branch</span> a (<span class="type">Tree</span> a) (<span class="type">Tree</span> a) </span><br><span class="line">            <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> (<span class="type">Tree</span> <span class="type">Int</span>) <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="keyword">do</span></span><br><span class="line">      mn &lt;- (arbitrary :: <span class="type">Gen</span> <span class="type">Int</span>)</span><br><span class="line">      <span class="type">Positive</span> delta &lt;- arbitrary</span><br><span class="line">      <span class="keyword">let</span> mx = mn + delta</span><br><span class="line">      searchTree mn mx</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      searchTree :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Gen</span> (<span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line">      searchTree mn mx </span><br><span class="line">         | mn &gt;= mx = pure <span class="type">Leaf</span></span><br><span class="line">         | otherwise = <span class="keyword">do</span></span><br><span class="line">            v &lt;- choose (mn,mx)</span><br><span class="line">            l &lt;- searchTree mn v</span><br><span class="line">            r &lt;- searchTree (v+<span class="number">1</span>) mx</span><br><span class="line">            pure (<span class="type">Branch</span> v l r)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- The Either Monad</span></span><br><span class="line"><span class="title">studentNames</span> :: [<span class="type">ZID</span>] -&gt; <span class="type">Either</span> <span class="type">ZID</span> [<span class="type">Name</span>]</span><br><span class="line"><span class="title">studentNames</span> [] = pure []</span><br><span class="line"><span class="title">studentNames</span> (z:zs) = <span class="keyword">do</span> </span><br><span class="line">     n  &lt;- <span class="keyword">case</span> lookup z db <span class="keyword">of</span></span><br><span class="line">             <span class="type">Just</span> v -&gt; <span class="type">Right</span> v</span><br><span class="line">             <span class="type">Nothing</span> -&gt; <span class="type">Left</span> z</span><br><span class="line">     ns &lt;- studentNames zs</span><br><span class="line">     pure (n:ns)</span><br></pre></td></tr></table></figure>



<h1 id="Static-Assurance-with-Types"><a href="#Static-Assurance-with-Types" class="headerlink" title="Static Assurance with Types"></a>Static Assurance with Types</h1><h2 id="Static-Assureance"><a href="#Static-Assureance" class="headerlink" title="Static Assureance"></a>Static Assureance</h2><h3 id="Methods-of-Assurance"><a href="#Methods-of-Assurance" class="headerlink" title="Methods of Assurance"></a>Methods of Assurance</h3><blockquote>
<p>Static means of assurance analyse a program <strong>without running it</strong>.</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/08/tPKreTBIiY8HuVq.png" alt="Screen Shot 2020-08-08 at 2.16.51 pm.png"></p>
<h3 id="Static-vs-Dynamic"><a href="#Static-vs-Dynamic" class="headerlink" title="Static vs. Dynamic"></a>Static vs. Dynamic</h3><blockquote>
<p>Static checks can be exhaustive.</p>
</blockquote>
<p><strong>Exhaustivity</strong></p>
<blockquote>
<p>An exhaustive check is a check that is able to analyse all possible executions of a program.</p>
</blockquote>
<ul>
<li>However, some properties cannot be checked statically in general (halting problem), or are intractable to feasibly check statically (state space explosion).</li>
<li>Dynamic checks cannot be exhaustive, but can be used to check some properties where static methods are unsuitable.</li>
</ul>
<h3 id="Compiler-Integration"><a href="#Compiler-Integration" class="headerlink" title="Compiler Integration"></a>Compiler Integration</h3><p>Most static and all dynamic methods of assurance are <strong>not</strong> integrated into the compilation process.</p>
<ul>
<li>You can compile and run your program even if it fails tests</li>
<li>You can change your program to diverge from your model checker model.</li>
<li>Your proofs can diverge from your implementation.</li>
</ul>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><blockquote>
<p>Because types <strong>are</strong> integrated into the compiler, they cannot diverge from the source code. This means that type signatures are a kind of <strong>machine-checked documentation</strong> for your code.</p>
</blockquote>
<p>Types are the most widely used kind of formal verification in programming today. </p>
<ul>
<li>They are checked automatically by the compiler. </li>
<li>They can be extended to encompass properties and proof systems with very high expressivity (covered next week). </li>
<li>They are an exhaustive analysis</li>
</ul>
<h2 id="Phantom-Types"><a href="#Phantom-Types" class="headerlink" title="Phantom Types"></a>Phantom Types</h2><blockquote>
<p>A type parameter is phantom if it does not appear in the right hand side of the type definition.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Size</span> x = <span class="type">S</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure>

<p>Lets examine each one of the following use cases:</p>
<ul>
<li>We can use this parameter to track what <strong>data invariants</strong> have been established about a value.</li>
<li>We can use this parameter to track information about the representation (e.g. units of measure).</li>
<li>We can use this parameter to enforce an <strong>ordering</strong> of operations performed on these values (<strong>type state</strong>).</li>
</ul>
<h3 id="Validation-1"><a href="#Validation-1" class="headerlink" title="Validation"></a>Validation</h3><p>Suppose we have</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">UG</span> <span class="comment">-- empty type</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PG</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">StudentID</span> x = <span class="type">SID</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure>

<p>We can define a smart constructor that specialises the type parameter:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sid</span> :: <span class="type">Int</span> -&gt; <span class="type">Either</span> (<span class="type">StudentID</span> <span class="type">UG</span>)</span><br><span class="line">                     (<span class="type">StudentID</span> <span class="type">PG</span>)</span><br></pre></td></tr></table></figure>

<p>Define functions:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">enrolInCOMP3141</span> :: <span class="type">StudentID</span> <span class="type">UG</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">lookupTranscript</span> :: <span class="type">StudentID</span> x -&gt; <span class="type">IO</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>

<h3 id="Units-of-Measure"><a href="#Units-of-Measure" class="headerlink" title="Units of Measure"></a>Units of Measure</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Kilometres</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Miles</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Value</span> x = <span class="type">U</span> <span class="type">Int</span></span></span><br><span class="line"><span class="title">sydneyToMelbourne</span> = (<span class="type">U</span> <span class="number">877</span> :: <span class="type">Value</span> <span class="type">Kilometres</span>)</span><br><span class="line"><span class="title">losAngelesToSanFran</span> = (<span class="type">U</span> <span class="number">383</span> :: <span class="type">Value</span> <span class="type">Miles</span>)</span><br><span class="line"><span class="comment">-- Note the arguments to area must have the same unit</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Square</span> a</span></span><br><span class="line"><span class="title">area</span> :: <span class="type">Value</span> m -&gt; <span class="type">Value</span> m -&gt; <span class="type">Value</span> (<span class="type">Square</span> m)</span><br><span class="line"><span class="title">area</span> (<span class="type">U</span> x) (<span class="type">U</span> y) = <span class="type">U</span> (x * y)</span><br></pre></td></tr></table></figure>

<h3 id="Type-State"><a href="#Type-State" class="headerlink" title="Type State"></a>Type State</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">  A Socket can either be ready to recieve data, or busy. If the socket is busy, the user</span></span><br><span class="line"><span class="comment">  must first use the wait operation, which blocks until the socket is ready. If the socket</span></span><br><span class="line"><span class="comment">  is ready, the user can use the send operation to send string data, which will make the</span></span><br><span class="line"><span class="comment">  socket busy again.</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Busy</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Ready</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Socket</span> s = <span class="type">Socket</span> ...</span></span><br><span class="line"><span class="title">wait</span> :: <span class="type">Socket</span> <span class="type">Busy</span> -&gt; <span class="type">IO</span> (<span class="type">Socket</span> <span class="type">Ready</span>)</span><br><span class="line"><span class="title">send</span> :: <span class="type">Socket</span> <span class="type">Ready</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> (<span class="type">Socket</span> <span class="type">Busy</span>)</span><br><span class="line"><span class="comment">-- assumption: use the socket in a linear way(only use once)</span></span><br></pre></td></tr></table></figure>

<h4 id="Linearity-and-Type-State"><a href="#Linearity-and-Type-State" class="headerlink" title="Linearity and Type State"></a>Linearity and Type State</h4><p>The previous code assumed that we didn’t re-use old Sockets:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">send2</span> :: <span class="type">Socket</span> <span class="type">Ready</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line">       -&gt; <span class="type">IO</span> (<span class="type">Socket</span> <span class="type">Busy</span>)</span><br><span class="line"><span class="title">send2</span> s x y = <span class="keyword">do</span> s' &lt;- send s x</span><br><span class="line">                 s'' &lt;- wait s'</span><br><span class="line">                 s''' &lt;- send s'' y</span><br><span class="line">                 pure s'''</span><br><span class="line"><span class="comment">-- But we can just re-use old values to send without waiting:</span></span><br><span class="line"><span class="title">send2'</span> s x y = <span class="keyword">do</span> _ &lt;- send s x</span><br><span class="line">                 s' &lt;- send s y</span><br><span class="line">                 pure s'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><em>Linear type</em></strong> systems can solve this, but not in Haskell (yet)</p>
</blockquote>
<h3 id="Datatype-Promotion"><a href="#Datatype-Promotion" class="headerlink" title="Datatype Promotion"></a>Datatype Promotion</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">UG</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PG</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">StudentID</span> x = <span class="type">SID</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure>

<p>Defining empty data types for our tags is untyped. We can have StudentID UG, but also StudentID String.</p>
<p>The DataKinds language extension lets us use data types as kinds:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds, KindSignatures #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Stream</span> = <span class="type">UG</span> | <span class="type">PG</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">StudentID</span> (<span class="title">x</span> :: <span class="type">Stream</span>) = <span class="type">SID</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">postgrad</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">postgrad</span> = [<span class="number">3253158</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">makeStudentID</span> :: <span class="type">Int</span> -&gt; <span class="type">Either</span> (<span class="type">StudentID</span> <span class="type">UG</span>) (<span class="type">StudentID</span> <span class="type">PG</span>)</span><br><span class="line"><span class="title">makeStudentID</span> i | i `elem` postgrad = <span class="type">Right</span> (<span class="type">SID</span> i) </span><br><span class="line">                | otherwise         = <span class="type">Left</span>  (<span class="type">SID</span> i)</span><br><span class="line"></span><br><span class="line"><span class="title">enrollInCOMP3141</span> :: <span class="type">StudentID</span> <span class="type">UG</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">enrollInCOMP3141</span> (<span class="type">SID</span> x) </span><br><span class="line">  = putStrLn (show x ++ <span class="string">" enrolled in COMP3141!"</span>)</span><br></pre></td></tr></table></figure>



<h2 id="GADTs"><a href="#GADTs" class="headerlink" title="GADTs"></a>GADTs</h2><p><strong>Untyped Evaluator</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> t = <span class="type">BConst</span> <span class="type">Bool</span></span></span><br><span class="line">            | <span class="type">IConst</span> <span class="type">Int</span></span><br><span class="line">            | <span class="type">Times</span> (<span class="type">Expr</span> <span class="type">Int</span>) (<span class="type">Expr</span> <span class="type">Int</span>)</span><br><span class="line">            | <span class="type">Less</span> (<span class="type">Expr</span> <span class="type">Int</span>) (<span class="type">Expr</span> <span class="type">Int</span>)</span><br><span class="line">            | <span class="type">And</span> (<span class="type">Expr</span> <span class="type">Bool</span>) (<span class="type">Expr</span> <span class="type">Bool</span>)</span><br><span class="line">            | <span class="type">If</span> (<span class="type">Expr</span> <span class="type">Bool</span>) (<span class="type">Expr</span> t) (<span class="type">Expr</span> t)</span><br><span class="line">            <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Value</span> = <span class="type">BVal</span> <span class="type">Bool</span> | <span class="type">IVal</span> <span class="type">Int</span></span></span><br><span class="line">             <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Value</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">BConst</span> b) = <span class="type">BVal</span> b</span><br><span class="line"><span class="title">eval</span> (<span class="type">IConst</span> i) = <span class="type">IVal</span> i</span><br><span class="line"><span class="title">eval</span> (<span class="type">Times</span> e1 e2) = <span class="keyword">case</span> (eval e1, eval e2) <span class="keyword">of</span> </span><br><span class="line">                       (<span class="type">IVal</span> i1, <span class="type">IVal</span> i2) -&gt; <span class="type">IVal</span> (i1 * i2)</span><br><span class="line"><span class="title">eval</span> (<span class="type">Less</span> e1 e2)  = <span class="keyword">case</span> (eval e1, eval e2) <span class="keyword">of</span></span><br><span class="line">                       (<span class="type">IVal</span> i1, <span class="type">IVal</span> i2) -&gt; <span class="type">BVal</span> (i1 &lt; i2) </span><br><span class="line"><span class="title">eval</span> (<span class="type">And</span> e1 e2)  = <span class="keyword">case</span> (eval e1, eval e2) <span class="keyword">of</span></span><br><span class="line">                       (<span class="type">BVal</span> b1, <span class="type">BVal</span> b2) -&gt; <span class="type">BVal</span> (b1 &amp;&amp; b2) </span><br><span class="line"><span class="title">eval</span> (<span class="type">If</span> ec et ee) = </span><br><span class="line">  <span class="keyword">case</span> eval ec <span class="keyword">of</span> </span><br><span class="line">    <span class="type">BVal</span> <span class="type">True</span>  -&gt; eval et</span><br><span class="line">    <span class="type">BVal</span> <span class="type">False</span> -&gt; eval ee</span><br><span class="line"><span class="comment">-- partial function</span></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> <span class="type">Value</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">BConst</span> b) = pure (<span class="type">BVal</span> b)</span><br><span class="line"><span class="title">eval</span> (<span class="type">IConst</span> i) = pure (<span class="type">IVal</span> i)</span><br><span class="line"><span class="title">eval</span> (<span class="type">Times</span> e1 e2) = <span class="keyword">do</span></span><br><span class="line">     v1 &lt;- eval e1</span><br><span class="line">     v2 &lt;- eval e2</span><br><span class="line">     <span class="keyword">case</span> (v1,v2) <span class="keyword">of</span></span><br><span class="line">       (<span class="type">IVal</span> v1', <span class="type">IVal</span> v2') -&gt; pure (<span class="type">IVal</span> (v1' * v2'))</span><br><span class="line">       _ -&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Less</span> e1 e2) = <span class="keyword">do</span></span><br><span class="line">     v1 &lt;- eval e1</span><br><span class="line">     v2 &lt;- eval e2</span><br><span class="line">     <span class="keyword">case</span> (v1,v2) <span class="keyword">of</span></span><br><span class="line">       (<span class="type">IVal</span> v1', <span class="type">IVal</span> v2') -&gt; pure (<span class="type">BVal</span> (v1' &lt; v2'))</span><br><span class="line">       _ -&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">And</span> e1 e2) = <span class="keyword">do</span></span><br><span class="line">     v1 &lt;- eval e1</span><br><span class="line">     v2 &lt;- eval e2</span><br><span class="line">     <span class="keyword">case</span> (v1,v2) <span class="keyword">of</span></span><br><span class="line">       (<span class="type">BVal</span> v1', <span class="type">BVal</span> v2') -&gt; pure (<span class="type">BVal</span> (v1' &amp;&amp; v2'))</span><br><span class="line">       _ -&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">If</span> ec et ee) = <span class="keyword">do</span></span><br><span class="line">     v1 &lt;- eval ec</span><br><span class="line">     <span class="keyword">case</span> v1 <span class="keyword">of</span></span><br><span class="line">       (<span class="type">BVal</span> <span class="type">True</span>) -&gt; eval et</span><br><span class="line">       (<span class="type">BVal</span> <span class="type">False</span>) -&gt; eval ee</span><br></pre></td></tr></table></figure>

<h3 id="GADTs-1"><a href="#GADTs-1" class="headerlink" title="GADTs"></a>GADTs</h3><blockquote>
<p>Generalised Algebraic Datatypes (<strong><em>GADTs</em></strong>) is an extension to Haskell that, among other things, allows data types to be specified by writing the types of their constructors.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs, KindSignatures #-&#125;</span></span><br><span class="line"><span class="comment">-- Unary natural numbers, e.g. 3 is S (S (S Z))</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span></span></span><br><span class="line"><span class="comment">-- is the same as</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> :: * where</span></span><br><span class="line"><span class="type">Z</span> :: <span class="type">Nat</span></span><br><span class="line"><span class="type">S</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>When combined with the <em>type indexing</em> trick of phantom types, this becomes very powerful!</p>
</blockquote>
<p><strong>Typed Evaluator</strong></p>
<blockquote>
<p>There is now only one set of precisely-typed constructors.</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs, KindSignatures #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> :: * -&gt; * where</span></span><br><span class="line">  <span class="type">BConst</span> :: <span class="type">Bool</span> -&gt; <span class="type">Expr</span> <span class="type">Bool</span></span><br><span class="line">  <span class="type">IConst</span> :: <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line">  <span class="type">Times</span>  :: <span class="type">Expr</span> <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line">  <span class="type">Less</span>   :: <span class="type">Expr</span> <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Bool</span></span><br><span class="line">  <span class="type">And</span>    :: <span class="type">Expr</span> <span class="type">Bool</span> -&gt; <span class="type">Expr</span> <span class="type">Bool</span> -&gt; <span class="type">Expr</span> <span class="type">Bool</span></span><br><span class="line">  <span class="type">If</span>     :: <span class="type">Expr</span> <span class="type">Bool</span> -&gt; <span class="type">Expr</span> a -&gt; <span class="type">Expr</span> a -&gt; <span class="type">Expr</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> t -&gt; t</span><br><span class="line"><span class="title">eval</span> (<span class="type">IConst</span> i)    = i</span><br><span class="line"><span class="title">eval</span> (<span class="type">BConst</span> b)    = b</span><br><span class="line"><span class="title">eval</span> (<span class="type">Times</span> e1 e2) = eval e1 * eval e2</span><br><span class="line"><span class="title">eval</span> (<span class="type">Less</span> e1 e2)  = eval e1 &lt; eval e2</span><br><span class="line"><span class="title">eval</span> (<span class="type">And</span> e1 e2)   = eval e1 &amp;&amp; eval e2</span><br><span class="line"><span class="title">eval</span> (<span class="type">If</span> ec et ee) = <span class="keyword">if</span> eval ec <span class="keyword">then</span> eval et <span class="keyword">else</span> eval ee</span><br></pre></td></tr></table></figure>

<h3 id="Lists-3"><a href="#Lists-3" class="headerlink" title="Lists"></a>Lists</h3><p>We could define our own list type using GADT syntax as follows:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> (<span class="title">a</span> :: *) :: * where</span></span><br><span class="line"><span class="type">Nil</span> :: <span class="type">List</span> a</span><br><span class="line"><span class="type">Cons</span> :: a -&gt; <span class="type">List</span> a -&gt; <span class="type">List</span> a</span><br><span class="line"><span class="comment">-- head (hd) and tail (tl) functions are partial </span></span><br><span class="line"><span class="title">hd</span> (<span class="type">Cons</span> x xs) = x</span><br><span class="line"><span class="title">tl</span> (<span class="type">Cons</span> x xs) = xs</span><br></pre></td></tr></table></figure>

<p>We will constrain the domain of these functions by tracking the length of the list on the type level.</p>
<h4 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs, KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds, StandaloneDeriving, TypeFamilies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">plus</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span> </span><br><span class="line"><span class="title">plus</span> <span class="type">Z</span> n = n</span><br><span class="line"><span class="title">plus</span> (<span class="type">S</span> m) n = <span class="type">S</span> (plus m n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Plus</span> (<span class="title">m</span> :: <span class="type">Nat</span>) (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Plus</span> <span class="type">Z</span> n = n</span><br><span class="line">  <span class="type">Plus</span> (<span class="type">S</span> m) n = <span class="type">S</span> (<span class="type">Plus</span> m n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> (<span class="title">a</span> :: *) :: <span class="type">Nat</span> -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> a <span class="type">Z</span></span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Vec</span> a n)</span><br><span class="line"></span><br><span class="line"><span class="title">appendV</span> :: <span class="type">Vec</span> a m -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a (<span class="type">Plus</span> m n)</span><br><span class="line"><span class="title">appendV</span> <span class="type">Nil</span> ys         = ys</span><br><span class="line"><span class="title">appendV</span> (<span class="type">Cons</span> x xs) ys = <span class="type">Cons</span> x (appendV xs ys)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0: Z</span></span><br><span class="line"><span class="comment">-- 1: S Z</span></span><br><span class="line"><span class="comment">-- 2: S (S Z)</span></span><br><span class="line"></span><br><span class="line"><span class="title">hd</span> :: <span class="type">Vec</span> a (<span class="type">S</span> n) -&gt; a</span><br><span class="line"><span class="title">hd</span> (<span class="type">Cons</span> x xs) = x</span><br><span class="line"></span><br><span class="line"><span class="title">mapVec</span> :: (a -&gt; b) -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> b n</span><br><span class="line"><span class="title">mapVec</span> f <span class="type">Nil</span> = <span class="type">Nil</span></span><br><span class="line"><span class="title">mapVec</span> f (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (f x) (mapVec f xs)</span><br></pre></td></tr></table></figure>

<h3 id="Tradeoffs"><a href="#Tradeoffs" class="headerlink" title="Tradeoffs"></a>Tradeoffs</h3><p>The benefits of this extra static checking are obvious, however:</p>
<ul>
<li>It can be difficult to convince the Haskell type checker that your code is correct, even when it is.</li>
<li>Type-level encodings can make types more verbose and programs harder to understand.</li>
<li>Sometimes excessively detailed types can make type-checking very slow, hindering productivity</li>
</ul>
<p><strong>Pragmatism</strong></p>
<blockquote>
<p>We should use type-based encodings only when the assurance advantages outweigh the clarity disadvantages. </p>
<p>The typical use case for these richly-typed structures is to eliminate partial functions from our code base.</p>
<p> If we never use partial list functions, length-indexed vectors are not particularly useful</p>
</blockquote>
<h1 id="Theory-of-Types"><a href="#Theory-of-Types" class="headerlink" title="Theory of Types"></a>Theory of Types</h1><h2 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h2><blockquote>
<p>We can specify a logical system as a <em><strong>deductive system</strong></em> by providing a set of <strong>rules</strong> and <strong>axioms</strong> that describe how to prove various connectives.</p>
</blockquote>
<h3 id="Natural-Deduction"><a href="#Natural-Deduction" class="headerlink" title="Natural Deduction"></a>Natural Deduction</h3><blockquote>
<p>A way we can specify logic</p>
</blockquote>
<p>Each connective typically has <strong><em>introduction</em></strong> and <strong><em>elimination</em></strong> rules. For example, to prove an implication A → B holds, we must show that B holds assuming A. This introduction rule is written as:</p>
<p><img src="https://i.loli.net/2020/08/08/7zFBO4Ith8cuKJT.png" alt="Screen Shot 2020-08-08 at 4.58.09 pm.png"></p>
<h3 id="More-rules"><a href="#More-rules" class="headerlink" title="More rules"></a>More rules</h3><p>Implication also has an elimination rule, that is also called <strong><em>modus ponens</em></strong>:<br>$$\frac{\ulcorner \vdash A\rightarrow B \space\space\space\space\space\space\space\space\ulcorner \vdash A}{\ulcorner \vdash  B}\rightarrow-E$$<br>Conjunction (and) has an introduction rule that follows our intuition:<br>$$<br>\frac{\ulcorner \vdash A\space\space\space\space\space\space\space\space\space \ulcorner \vdash B}{\ulcorner \vdash A\land B}\land-I_1<br>$$<br>It has two elimination rules:<br>$$<br>\frac{\ulcorner \vdash A\land B}{\ulcorner \vdash A}\land-E_1\space\space\space\space\space\space\space\space\space\space\frac{\ulcorner \vdash A\land B}{\ulcorner \vdash B}\land-E_2<br>$$<br>Disjunction (or) has two introduction rules:<br>$$<br>\frac{\ulcorner \vdash A}{\ulcorner \vdash A\lor B}\land-I_1\space\space\space\space\space\space\space\space\space\space\frac{\ulcorner \vdash A}{\ulcorner \vdash A\lor B}\land-I_2<br>$$<br>Disjunction elimination is a little unusual:<br>$$<br>\frac{\ulcorner \vdash A\lor B\space\space\space\space\space\space\space A,\ulcorner \vdash P \space\space\space\space\space\space\space B,\ulcorner \vdash P}{\ulcorner \vdash P}\lor-E<br>$$<br>The true literal, written T, has only an introduction:<br>$$<br>\frac{}{\ulcorner \vdash \top}<br>$$<br>And false, written ⊥, has just elimination (ex falso quodlibet):<br>$$<br>\frac{\ulcorner \vdash \bot}{\ulcorner \vdash P}<br>$$<br>Typically we just define：<br>$$<br>\neg A \equiv(A\rightarrow\bot)<br>$$</p>
<h3 id="Constructive-Logic"><a href="#Constructive-Logic" class="headerlink" title="Constructive Logic"></a>Constructive Logic</h3><p>The logic we have expressed so far does not admit the law of the excluded middle:<br>$$<br>P\lor\neg P<br>$$<br>Or the equivalent double negation elimination:<br>$$<br>(\neg\neg P)\rightarrow P<br>$$<br>This is because it is a <strong><em>constructive</em></strong> logic that does not allow us to do proof by contradiction.</p>
<h2 id="Typed-Lambda-Calculus"><a href="#Typed-Lambda-Calculus" class="headerlink" title="Typed Lambda Calculus"></a>Typed Lambda Calculus</h2><h3 id="Boiling-Haskell-Down"><a href="#Boiling-Haskell-Down" class="headerlink" title="Boiling Haskell Down"></a>Boiling Haskell Down</h3><p>The theoretical properties we will describe also apply to Haskell, but we need a smaller language for demonstration purposes.</p>
<ul>
<li>No user-defined types, just a small set of built-in types.</li>
<li>No polymorphism (type variables)</li>
<li>Just lambdas (λx.e) to define functions or bind variables.</li>
</ul>
<p>This language is a very minimal functional language, called the <strong>simply typed lambda calculus</strong>, originally due to Alonzo Church.</p>
<p>Our small set of built-in types are intended to be enough to express most of the data types we would otherwise define.</p>
<p>We are going to use logical inference rules to specify how expressions are given types (<strong><em>typing rules</em></strong>).</p>
<h3 id="Function-Types"><a href="#Function-Types" class="headerlink" title="Function Types"></a>Function Types</h3><p>We create values of a function type A → B using lambda expressions:<br>$$<br>\frac{x :: A, \ulcorner\vdash e::B}{\ulcorner\vdash\lambda x.e::A\rightarrow B}<br>$$<br>The typing rule for function application is as follows:<br>$$<br>\frac{\ulcorner\vdash e_1:: A\rightarrow B\space\space\space\space\space\space\space\space \ulcorner\vdash e_2::A}{\ulcorner\vdash e_1 e_2:: B}<br>$$</p>
<h3 id="Composite-Data-Types"><a href="#Composite-Data-Types" class="headerlink" title="Composite Data Types"></a>Composite Data Types</h3><p>In addition to functions, most programming languages feature ways to compose types together to produce new types, such as: Classes, Tuples, Structs, Unions, Records…</p>
<h4 id="Product-Types"><a href="#Product-Types" class="headerlink" title="Product Types"></a>Product Types</h4><p>For simply typed lambda calculus, we will accomplish this with tuples, also called product types. <strong><em>(A, B)</em></strong></p>
<p>We won’t have type declarations, named fields or anything like that. More than two values can be combined by nesting products, for example a three dimensional vector:<br>$$<br>\text{(Int, (Int, Int))}<br>$$</p>
<h4 id="Constructors-and-Eliminators"><a href="#Constructors-and-Eliminators" class="headerlink" title="Constructors and Eliminators"></a>Constructors and Eliminators</h4><p>We can construct a product type the same as Haskell tuples:<br>$$<br>\frac{\ulcorner\vdash e_1:: A\space\space\space\space\space\space\space\space \ulcorner\vdash e_2::B}{\ulcorner\vdash(e_1, e_2):: (A, B)}<br>$$<br>The only way to extract each component of the product is to use the fst and snd eliminators:<br>$$<br>\frac{\ulcorner\vdash e:: (A,B)}{\ulcorner\vdash \text{fst }e::A}\space\space\space\space\space\space\space\space \frac{\ulcorner\vdash e:: (A,B)}{\ulcorner\vdash \text{snd }e::B}<br>$$</p>
<h4 id="Unit-Types"><a href="#Unit-Types" class="headerlink" title="Unit Types"></a>Unit Types</h4><p>Currently, we have no way to express a type with just one value. This may seem useless at first, but it becomes useful in combination with other types. We’ll introduce the unit type from Haskell, written (), which has exactly one inhabitant, also written ():<br>$$<br>\frac{}{\ulcorner\vdash ():: ()}<br>$$</p>
<h4 id="Disjunctive-Composition"><a href="#Disjunctive-Composition" class="headerlink" title="Disjunctive Composition"></a>Disjunctive Composition</h4><p>We can’t, with the types we have, express a type with exactly three values.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TrafficLight</span> = <span class="type">Red</span> | <span class="type">Amber</span> | <span class="type">Green</span></span></span><br></pre></td></tr></table></figure>

<p>In general we want to express data that can be one of multiple alternatives, that contain different bits of data.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Length</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Angle</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Rect</span> <span class="type">Length</span> <span class="type">Length</span></span></span><br><span class="line">           | <span class="type">Circle</span> <span class="type">Length</span> | <span class="type">Point</span></span><br><span class="line">           | <span class="type">Triangle</span> <span class="type">Angle</span> <span class="type">Length</span> <span class="type">Length</span></span><br></pre></td></tr></table></figure>

<h4 id="Sum-Types"><a href="#Sum-Types" class="headerlink" title="Sum Types"></a>Sum Types</h4><p>We’ll build in the Haskell Either type to express the possibility that data may be one of two forms.<br>$$<br>\text{Either } A \space B<br>$$<br>These types are also called <em><strong>sum types</strong></em>.</p>
<p>Our TrafficLight type can be expressed (grotesquely) as a sum of units:<br>$$<br>\text{TrafficLight } \simeq \text{Either () (Either () ())}<br>$$</p>
<h5 id="Constructors-and-Eliminators-for-Sums"><a href="#Constructors-and-Eliminators-for-Sums" class="headerlink" title="Constructors and Eliminators for Sums"></a>Constructors and Eliminators for Sums</h5><p>To make a value of type Either A B, we invoke one of the two <strong>constructors</strong>:<br>$$<br>\frac{\ulcorner\vdash e:: A}{\ulcorner\vdash \text{Left }e::\text{Either }A\space B} \space\space\space\space \space\space\space\space \frac{\ulcorner\vdash e:: B}{\ulcorner\vdash \text{Right }e::\text{Either }A\space B}<br>$$<br>We can branch based on which alternative is used using <strong>pattern matching</strong>:<br>$$<br>\frac{\ulcorner\vdash e::\text{Either }A\space B\space\space\space \space \space\space\space\space x::A,\ulcorner\vdash e_1::P\space \space\space\space\space\space\space\space y::B,\ulcorner\vdash e_2::P}{\ulcorner\vdash (\textbf{case }e\textbf{ of}\text{ Left x}\rightarrow e_1; \text{ Right y}\rightarrow e_2)::P}<br>$$<br><strong>Example</strong></p>
<p>Our traffic light type has three values as required:<br>$$<br>\begin{align*}<br>\text{TrafficLight } &amp;\simeq \text{Either () (Either () ())}\\<br>\text{Red } &amp;\simeq \text{Left ()}\\<br>\text{Amber } &amp;\simeq \text{Right (Left ())}\\<br>\text{Green } &amp;\simeq \text{Right (Right (Left ()}\\<br>\end{align*}<br>$$</p>
<h3 id="The-Empty-Type"><a href="#The-Empty-Type" class="headerlink" title="The Empty Type"></a>The Empty Type</h3><p>We add another type, called Void, that has no inhabitants. Because it is empty, there is no way to construct it. </p>
<p>We do have a way to eliminate it, however:<br>$$<br>\frac{\ulcorner\vdash e::\text{Void}}{\ulcorner\vdash \text{absurd }e::P}<br>$$<br>If I have a variable of the <strong>empty</strong> type in scope, we must be looking at an expression that will <strong>never</strong> be evaluated. Therefore, we can assign any type we like to this expression, because it will never be executed.</p>
<h3 id="Gathering-Rules"><a href="#Gathering-Rules" class="headerlink" title="Gathering Rules"></a>Gathering Rules</h3><p>$$<br>\frac{\ulcorner\vdash e::\text{Void}}{\ulcorner\vdash \text{absurd }e::P}\space\space\space\space\space\space\frac{}{\ulcorner\vdash ():: ()}\\<br>\frac{\ulcorner\vdash e:: A}{\ulcorner\vdash \text{Left }e::\text{Either }A\space B} \space\space\space\space \space\space\space\space \frac{\ulcorner\vdash e:: B}{\ulcorner\vdash \text{Right }e::\text{Either }A\space B}\\<br>\frac{\ulcorner\vdash e::\text{Either }A\space B\space\space\space \space \space\space\space\space x::A,\ulcorner\vdash e_1::P\space \space\space\space\space\space\space\space y::B,\ulcorner\vdash e_2::P}{\ulcorner\vdash (\textbf{case }e\textbf{ of}\text{ Left x}\rightarrow e_1; \text{ Right y}\rightarrow e_2)::P}\\<br>\frac{\ulcorner\vdash e_1:: A\space\space\space\space\space\space \ulcorner\vdash e_2::B}{\ulcorner\vdash(e_1, e_2):: (A, B)}\space\space\space\space\space\space\frac{\ulcorner\vdash e:: (A,B)}{\ulcorner\vdash \text{fst }e::A}\space\space\space\space\space\space\frac{\ulcorner\vdash e:: (A,B)}{\ulcorner\vdash \text{snd }e::B}\\<br>\frac{\ulcorner\vdash e_1:: A\rightarrow B\space\space\space\space\space\space\ulcorner\vdash e_2::A}{\ulcorner\vdash e_1 e_2::B}\space\space\space\space\space\space\space\frac{x :: A, \ulcorner\vdash e::B}{\ulcorner\vdash\lambda x.e::A\rightarrow B}<br>$$</p>
<h3 id="Removing-Terms"><a href="#Removing-Terms" class="headerlink" title="Removing Terms. . ."></a>Removing Terms. . .</h3><p>$$<br>\frac{\ulcorner\vdash\text{Void}}{\ulcorner\vdash P}\space\space\space\space\space\space\frac{}{\ulcorner\vdash ()}\\<br>\frac{\ulcorner\vdash A}{\ulcorner\vdash\text{Either }A\space B} \space\space\space\space \space\space\space\space \frac{\ulcorner\vdash B}{\ulcorner\vdash\text{Either }A\space B}\\<br>\frac{\ulcorner\vdash \text{Either }A\space B\space\space\space \space \space\space\space\space A,\ulcorner\vdash P\space \space\space\space\space\space\space\space B,\ulcorner\vdash P}{\ulcorner\vdash P}\\<br>\frac{\ulcorner\vdash A\space\space\space\space\space\space \ulcorner\vdash B}{\ulcorner\vdash(A, B)}\space\space\space\space\space\space\frac{\ulcorner\vdash (A,B)}{\ulcorner\vdash A}\space\space\space\space\space\space \frac{\ulcorner\vdash (A,B)}{\ulcorner\vdash B}\\<br>\frac{\ulcorner\vdash A\rightarrow B\space\space\space\space\space\space\ulcorner\vdash A}{\ulcorner\vdash B}\space\space\space\space\space\space\space\frac{ A, \ulcorner\vdash B}{\ulcorner\vdash A\rightarrow B}<br>$$</p>
<blockquote>
<p>This looks exactly like constructive logic! If we can construct a program of a certain type, we have also created a proof of a program</p>
</blockquote>
<h3 id="The-Curry-Howard-Correspondence"><a href="#The-Curry-Howard-Correspondence" class="headerlink" title="The Curry-Howard Correspondence"></a>The Curry-Howard Correspondence</h3><p>This correspondence goes by many names, but is usually attributed to Haskell Curry and William Howard. </p>
<p>It is a <strong>very deep</strong> result:</p>
<table>
<thead>
<tr>
<th>Programming</th>
<th>Logic</th>
</tr>
</thead>
<tbody><tr>
<td>Types</td>
<td>Propositions</td>
</tr>
<tr>
<td>Programs</td>
<td>Proofs</td>
</tr>
<tr>
<td>Evaluation</td>
<td>Proof Simplification</td>
</tr>
</tbody></table>
<p>It turns out, no matter what logic you want to define, there is always a corresponding λ-calculus, and vice versa.</p>
<table>
<thead>
<tr>
<th>λ-calculus</th>
<th>Logic</th>
</tr>
</thead>
<tbody><tr>
<td>Typed λ-Calculus</td>
<td>Constructive Logic</td>
</tr>
<tr>
<td>Continuations</td>
<td>Classical Logic</td>
</tr>
<tr>
<td>Monads</td>
<td>Modal Logic</td>
</tr>
<tr>
<td>Linear Types, Session Types</td>
<td>Linear Logic</td>
</tr>
<tr>
<td>Region Types</td>
<td>Separation Logic</td>
</tr>
</tbody></table>
<h3 id="Translating"><a href="#Translating" class="headerlink" title="Translating"></a>Translating</h3><p>We can translate logical connectives to types and back:</p>
<table>
<thead>
<tr>
<th>Types</th>
<th>logical connectives</th>
</tr>
</thead>
<tbody><tr>
<td>Tuples</td>
<td>Conjuction($\land$)</td>
</tr>
<tr>
<td>Either</td>
<td>Disjunction (∨)</td>
</tr>
<tr>
<td>Functions</td>
<td>Implication</td>
</tr>
<tr>
<td>()</td>
<td>True</td>
</tr>
<tr>
<td>Void</td>
<td>False</td>
</tr>
</tbody></table>
<p>We can also translate our equational reasoning on programs into <strong><em>proof simplification</em></strong> on proofs!</p>
<h4 id="Proof-Simplification"><a href="#Proof-Simplification" class="headerlink" title="Proof Simplification"></a>Proof Simplification</h4><p>Assuming A $∧$ B, we want to prove B $∧$ A. We have this unpleasant proof:</p>
<p><img src="https://i.loli.net/2020/08/08/WCTwuMAhm7QHDvd.png" alt="Screen Shot 2020-08-08 at 8.14.24 pm.png"></p>
<p>Translating to types, we get: Assuming x :: (A, B), we want to construct (B, A).</p>
<p><img src="https://i.loli.net/2020/08/08/XzMvQbgn8wy3YdZ.png" alt="Screen Shot 2020-08-08 at 8.15.32 pm.png"></p>
<p>We know that<br>$$<br>\text{(snd x, snd (fst x, fst x))  =  (snd x, fst x)}<br>$$<br>Assuming x :: (A, B), we want to construct (B, A).</p>
<p><img src="https://i.loli.net/2020/08/08/t7hzkspYET83dwG.png" alt="Screen Shot 2020-08-08 at 8.17.29 pm.png"></p>
<p>Back to logic:</p>
<p><img src="https://i.loli.net/2020/08/08/2UzBCf5hT7EZLR9.png" alt="Screen Shot 2020-08-08 at 8.17.39 pm.png"></p>
<h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>As mentioned before, in dependently typed languages such as Agda and Idris, the distinction between value-level and type-level languages is removed, allowing us to refer to our program in types (i.e. propositions) and then construct programs of those types (i.e. proofs).</p>
<p>Generally, dependent types allow us to use rich types not just for programming, but also for verification via the Curry-Howard correspondence.</p>
<h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats"></a>Caveats</h3><p>All functions we define have to be total and terminating. Otherwise we get an inconsistent logic that lets us prove false things.</p>
<p>Most common calculi correspond to constructive logic, not classical ones, so principles like the law of excluded middle or double negation elimination do not hold.</p>
<h2 id="Algebraic-Type-Isomorphism"><a href="#Algebraic-Type-Isomorphism" class="headerlink" title="Algebraic Type Isomorphism"></a>Algebraic Type Isomorphism</h2><h3 id="Semiring-Structure"><a href="#Semiring-Structure" class="headerlink" title="Semiring Structure"></a>Semiring Structure</h3><blockquote>
<p>These types we have defined form an algebraic structure called a <strong><em>commutative semiring</em></strong></p>
</blockquote>
<p>Laws for <code>Either</code> and <code>Void</code>:</p>
<ul>
<li>Associativity: Either (Either A B) C $\simeq$ Either A (Either B C)</li>
<li>Identity: Either Void A  $\simeq$  A </li>
<li>Commutativity: Either A B  $\simeq$  Either B A</li>
</ul>
<p>Laws for tuples and 1:</p>
<ul>
<li>Associativity: ((A, B), C)  $\simeq$ (A,(B, C))</li>
<li>Identity: ((), A)  $\simeq$ A</li>
<li>Commutativity: (A, B)  $\simeq$ (B, A)</li>
</ul>
<p>Combining the two:</p>
<ul>
<li>Distributivity: (A, Either B C) $\simeq$ Either (A, B) (A, C)</li>
<li>Absorption: (Void, A) $\simeq$ Void</li>
</ul>
<p>What does  $\simeq$ mean here? It’s more than logical equivalence. Distinguish more things.</p>
<h3 id="Isomorphism"><a href="#Isomorphism" class="headerlink" title="Isomorphism"></a>Isomorphism</h3><blockquote>
<p>Two types A and B are <strong><em>isomorphic</em></strong>, written A $\simeq$ B, if there exists a bijection between them. This means that for each value in A we can find a unique value in B and vice versa.</p>
</blockquote>
<p><strong>Example:</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Switch</span> = <span class="type">On</span> <span class="type">Name</span> <span class="type">Int</span></span></span><br><span class="line">            | <span class="type">Off</span> <span class="type">Name</span></span><br></pre></td></tr></table></figure>

<p>Can be simplified to the isomorphic (Name, Maybe Int).</p>
<p><strong>Generic Programming</strong></p>
<blockquote>
<p>Representing data types generically as sums and products is the foundation for generic programming libraries such as GHC generics. This allows us to define algorithms that work on arbitrary data structures.</p>
</blockquote>
<h2 id="Polymorphism-and-Parametricty"><a href="#Polymorphism-and-Parametricty" class="headerlink" title="Polymorphism and Parametricty"></a>Polymorphism and Parametricty</h2><h3 id="Type-Quantifiers"><a href="#Type-Quantifiers" class="headerlink" title="Type Quantifiers"></a>Type Quantifiers</h3><p>Consider the type of fst:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fst</span> :: (a,b) -&gt; a</span><br></pre></td></tr></table></figure>

<p>This can be written more verbosely as:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fst</span> :: <span class="keyword">forall</span> a b. (a,b) -&gt; a</span><br></pre></td></tr></table></figure>

<p>Or, in a more mathematical notation:<br>$$<br>\text{fst}::\forall a\space b(a, b)\rightarrow a<br>$$<br>This kind of quantification over type variables is called <strong>parametric polymorphism</strong> or just <strong>polymorphism</strong> for short.</p>
<p>(It’s also called <strong>generics</strong> in some languages, but this terminology is bad)</p>
<h3 id="Curry-Howard"><a href="#Curry-Howard" class="headerlink" title="Curry-Howard"></a>Curry-Howard</h3><p>The type quantifier ∀ corresponds to a universal quantifier ∀, but it is <strong>not</strong> the same as the ∀ from first-order logic. What’s the difference?</p>
<p>First-order logic quantifiers range over a set of individuals or values, for example the natural numbers:<br>$$<br>\forall x. x+1 &gt;x<br>$$<br>These quantifiers range over <strong>propositions</strong> (types) themselves. It is analogous to <strong>second-order logic</strong>, not first-order:<br>$$<br>\forall A.\forall B\space A\land B \rightarrow B\land A\\<br>\forall A.\forall B\space (A, B) \rightarrow (B, A)<br>$$<br>The first-order quantifier has a type-theoretic analogue too (type indices), but this is not nearly as common as polymorphism.</p>
<h3 id="Generality"><a href="#Generality" class="headerlink" title="Generality"></a>Generality</h3><blockquote>
<p>A type A is more general than a type B, often written A $\sqsubseteq$ B, if type variables in A can be instantiated to give the type B.</p>
</blockquote>
<p>If we need a function of type Int → Int, a polymorphic function of type ∀a. a → a will do just fine, we can just instantiate the type variable to Int. But the reverse is not true. This gives rise to an ordering.</p>
<p><strong>Example</strong><br>$$<br>\text{Int}\rightarrow\text{Int} \sqsupseteq \forall z. z\rightarrow z\sqsupseteq \forall x\space y. x\rightarrow y\sqsupseteq\forall a. a<br>$$</p>
<h4 id="Constraining-Implementations"><a href="#Constraining-Implementations" class="headerlink" title="Constraining Implementations"></a>Constraining Implementations</h4><p>How many possible total, terminating implementations are there of a function of the following type? Many<br>$$<br>\text{Int}\rightarrow\text{Int}<br>$$<br>How about this type? 1<br>$$<br>\forall a. a\rightarrow a<br>$$</p>
<blockquote>
<p>Polymorphic type signatures constrain implementations.</p>
</blockquote>
<h3 id="Parametricity"><a href="#Parametricity" class="headerlink" title="Parametricity"></a>Parametricity</h3><blockquote>
<p>The principle of <strong>parametricity</strong> states that the result of polymorphic functions cannot depend on <strong>values</strong> of an abstracted type.</p>
<p>More formally, suppose I have a polymorphic function g that is polymorphic on type a. If run any arbitrary function f :: a → a on all the a values in the input of <em>g</em>, that will give the same results as running g first, then f on all the a values of the output.</p>
</blockquote>
<p><strong>Example:</strong><br>$$<br>foo :: ∀a. [a] → [a]<br>$$<br>We know that every element of the output occurs in the input. The parametricity theorem we get is, for all f :<br>$$<br>\text{foo }\circ(\text{map f}) = (\text{map f})\circ \text{foo}<br>$$</p>
<p>$$<br>head :: ∀a. [a] → a\\<br>\text{ f (head l) = head (map f l)}<br>$$</p>
<p>$$<br>(++) :: ∀a. [a] → [a] → [a]\\<br>\text{map f (a ++ b) = map f a ++ map f b}<br>$$</p>
<p>$$<br>concat :: ∀a. [[a]] → [a]\\<br>\text{map f (concat ls) = concat (map (map f ) ls)}<br>$$</p>
<h3 id="Higher-Order-Functions-1"><a href="#Higher-Order-Functions-1" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h3><p>$$<br>filter :: ∀a. (a → Bool) → [a] → [a]\\<br>\text{filter p (map f ls) = map f (filter (p ◦ f ) ls)}<br>$$</p>
<h3 id="Parametricity-Theorems"><a href="#Parametricity-Theorems" class="headerlink" title="Parametricity Theorems"></a>Parametricity Theorems</h3><p>Follow a similar structure. In fact it can be mechanically derived, using the relational parametricity framework invented by John C. Reynolds, and popularised by Wadler in the famous paper, “Theorems for Free!”1 . </p>
<p>Upshot: We can ask lambdabot on the Haskell IRC channel for these theorems.</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Haskell/">Haskell</a><a class="link-muted mr-2" rel="tag" href="/tags/Functional-Programming/">Functional Programming</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/09/Foundation%20of%20Concurreny/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Foundation of Concurrency</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/01/Mac%E8%A3%85spin%E5%92%8Cispin/"><span class="level-item">Mac装spin和ispin</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Tina"></figure><p class="title is-size-4 is-block line-height-inherit">Tina</p><p class="is-size-6 is-block">A student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>A secret</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/CutePikachu" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/CutePikachu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#Haskell-Introduction"><span class="mr-2">1</span><span>Haskell Introduction</span></a><ul class="menu-list"><li><a class="is-flex" href="#Currying"><span class="mr-2">1.1</span><span>Currying</span></a></li><li><a class="is-flex" href="#Tuples"><span class="mr-2">1.2</span><span>Tuples</span></a></li><li><a class="is-flex" href="#Higher-Order-Functions"><span class="mr-2">1.3</span><span>Higher Order Functions</span></a></li><li><a class="is-flex" href="#Lists"><span class="mr-2">1.4</span><span>Lists</span></a></li><li><a class="is-flex" href="#Map"><span class="mr-2">1.5</span><span>Map</span></a></li><li><a class="is-flex" href="#Strings"><span class="mr-2">1.6</span><span>Strings</span></a></li><li><a class="is-flex" href="#Functional-Composition"><span class="mr-2">1.7</span><span>Functional Composition</span></a></li><li><a class="is-flex" href="#Lists-1"><span class="mr-2">1.8</span><span>Lists</span></a></li><li><a class="is-flex" href="#List-Functions"><span class="mr-2">1.9</span><span>List Functions</span></a></li></ul></li><li><a class="is-flex" href="#Induction"><span class="mr-2">2</span><span>Induction</span></a></li><li><a class="is-flex" href="#Data-Types"><span class="mr-2">3</span><span>Data Types</span></a><ul class="menu-list"><li><a class="is-flex" href="#Records"><span class="mr-2">3.1</span><span>Records</span></a></li><li><a class="is-flex" href="#Enumeration-Types"><span class="mr-2">3.2</span><span>Enumeration Types</span></a><ul class="menu-list"><li><a class="is-flex" href="#Algebraic-Data-Types"><span class="mr-2">3.2.1</span><span>Algebraic Data Types</span></a></li></ul></li><li><a class="is-flex" href="#Recursive-and-Parametric-Types"><span class="mr-2">3.3</span><span>Recursive and Parametric Types</span></a></li><li><a class="is-flex" href="#Types-in-Design"><span class="mr-2">3.4</span><span>Types in Design</span></a></li><li><a class="is-flex" href="#Partial-Functions"><span class="mr-2">3.5</span><span>Partial Functions</span></a></li></ul></li><li><a class="is-flex" href="#Type-Classes"><span class="mr-2">4</span><span>Type Classes</span></a><ul class="menu-list"><li><a class="is-flex" href="#Show"><span class="mr-2">4.1</span><span>Show</span></a></li><li><a class="is-flex" href="#Read"><span class="mr-2">4.2</span><span>Read</span></a></li><li><a class="is-flex" href="#Semigroup"><span class="mr-2">4.3</span><span>Semigroup</span></a></li><li><a class="is-flex" href="#Moniod"><span class="mr-2">4.4</span><span>Moniod</span></a></li><li><a class="is-flex" href="#Newtypes"><span class="mr-2">4.5</span><span>Newtypes</span></a></li><li><a class="is-flex" href="#Ord"><span class="mr-2">4.6</span><span>Ord</span></a></li><li><a class="is-flex" href="#Eq"><span class="mr-2">4.7</span><span>Eq</span></a></li></ul></li><li><a class="is-flex" href="#functor"><span class="mr-2">5</span><span>Funtors</span></a><ul class="menu-list"><li><a class="is-flex" href="#Types-and-Values"><span class="mr-2">5.1</span><span>Types and Values</span></a></li><li><a class="is-flex" href="#Kinds"><span class="mr-2">5.2</span><span>Kinds</span></a></li><li><a class="is-flex" href="#Lists-2"><span class="mr-2">5.3</span><span>Lists</span></a></li><li><a class="is-flex" href="#Functor"><span class="mr-2">5.4</span><span>Functor</span></a><ul class="menu-list"><li><a class="is-flex" href="#Functor-Laws"><span class="mr-2">5.4.1</span><span>Functor Laws</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Property-Based-Testing"><span class="mr-2">6</span><span>Property Based Testing</span></a><ul class="menu-list"><li><a class="is-flex" href="#Free-Properties"><span class="mr-2">6.1</span><span>Free Properties</span></a></li><li><a class="is-flex" href="#Logical-Properties"><span class="mr-2">6.2</span><span>Logical Properties</span></a></li><li><a class="is-flex" href="#Proofs"><span class="mr-2">6.3</span><span>Proofs</span></a></li><li><a class="is-flex" href="#Testing"><span class="mr-2">6.4</span><span>Testing</span></a></li><li><a class="is-flex" href="#Property-Based-Testing-1"><span class="mr-2">6.5</span><span>Property Based Testing</span></a><ul class="menu-list"><li><a class="is-flex" href="#PBT-vs-Unit-Testing"><span class="mr-2">6.5.1</span><span>PBT vs. Unit Testing</span></a></li><li><a class="is-flex" href="#Test-Data-Generation"><span class="mr-2">6.5.2</span><span>Test Data Generation</span></a></li><li><a class="is-flex" href="#Examples"><span class="mr-2">6.5.3</span><span>Examples</span></a></li><li><a class="is-flex" href="#Redundant-Properties"><span class="mr-2">6.5.4</span><span>Redundant Properties</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Lazy-Evaluation"><span class="mr-2">7</span><span>Lazy Evaluation</span></a><ul class="menu-list"><li><a class="is-flex" href="#Advantages"><span class="mr-2">7.1</span><span>Advantages</span></a></li><li><a class="is-flex" href="#Infinite-Data-Structures"><span class="mr-2">7.2</span><span>Infinite Data Structures</span></a></li></ul></li><li><a class="is-flex" href="#Data-Invariants-and-ADTs"><span class="mr-2">8</span><span>Data Invariants and ADTs</span></a><ul class="menu-list"><li><a class="is-flex" href="#Structure-of-a-Module"><span class="mr-2">8.1</span><span>Structure of a Module</span></a></li><li><a class="is-flex" href="#Data-Invariants"><span class="mr-2">8.2</span><span>Data Invariants</span></a></li><li><a class="is-flex" href="#Abstract-Data-Types"><span class="mr-2">8.3</span><span>Abstract Data Types</span></a></li><li><a class="is-flex" href="#Validation"><span class="mr-2">8.4</span><span>Validation</span></a></li></ul></li><li><a class="is-flex" href="#Data-Refinement"><span class="mr-2">9</span><span>Data Refinement</span></a><ul class="menu-list"><li><a class="is-flex" href="#Reasoning-about-ADTs"><span class="mr-2">9.1</span><span>Reasoning about ADTs</span></a></li><li><a class="is-flex" href="#Models-for-ADTs"><span class="mr-2">9.2</span><span>Models for ADTs</span></a></li><li><a class="is-flex" href="#Refinement-Relations"><span class="mr-2">9.3</span><span>Refinement Relations</span></a></li><li><a class="is-flex" href="#Abstraction-Functions"><span class="mr-2">9.4</span><span>Abstraction Functions</span></a></li><li><a class="is-flex" href="#Data-Refinement-1"><span class="mr-2">9.5</span><span>Data Refinement</span></a></li></ul></li><li><a class="is-flex" href="#Effects"><span class="mr-2">10</span><span>Effects</span></a><ul class="menu-list"><li><a class="is-flex" href="#Internal-vs-External-Effects"><span class="mr-2">10.1</span><span>Internal vs. External Effects</span></a></li><li><a class="is-flex" href="#Purity"><span class="mr-2">10.2</span><span>Purity</span></a></li><li><a class="is-flex" href="#Haskell-Functions"><span class="mr-2">10.3</span><span>Haskell Functions</span></a><ul class="menu-list"><li><a class="is-flex" href="#The-Danger-of-Implicit-Side-Effects"><span class="mr-2">10.3.1</span><span>The Danger of Implicit Side Effects</span></a></li><li><a class="is-flex" href="#Can-we-program-with-pure-functions"><span class="mr-2">10.3.2</span><span>Can we program with pure functions?</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#State"><span class="mr-2">11</span><span>State</span></a><ul class="menu-list"><li><a class="is-flex" href="#State-Passing"><span class="mr-2">11.1</span><span>State Passing</span></a></li><li><a class="is-flex" href="#State-1"><span class="mr-2">11.2</span><span>State</span></a></li><li><a class="is-flex" href="#IO"><span class="mr-2">11.3</span><span>IO</span></a></li><li><a class="is-flex" href="#Infectious-IO"><span class="mr-2">11.4</span><span>Infectious IO</span></a></li><li><a class="is-flex" href="#Haskell-Design-Strategy"><span class="mr-2">11.5</span><span>Haskell Design Strategy</span></a></li><li><a class="is-flex" href="#Benefits-of-an-IO-Type"><span class="mr-2">11.6</span><span>Benefits of an IO Type</span></a></li><li><a class="is-flex" href="#Mutable-Variables"><span class="mr-2">11.7</span><span>Mutable Variables</span></a><ul class="menu-list"><li><a class="is-flex" href="#Mutable-Variables-Locally"><span class="mr-2">11.7.1</span><span>Mutable Variables, Locally</span></a></li></ul></li><li><a class="is-flex" href="#QuickChecking-Effects"><span class="mr-2">11.8</span><span>QuickChecking Effects</span></a></li></ul></li><li><a class="is-flex" href="#Functor-1"><span class="mr-2">12</span><span>Functor</span></a><ul class="menu-list"><li><a class="is-flex" href="#QuickCheck-Generators"><span class="mr-2">12.1</span><span>QuickCheck Generators</span></a></li></ul></li><li><a class="is-flex" href="#Applicative-Functors"><span class="mr-2">13</span><span>Applicative Functors</span></a><ul class="menu-list"><li><a class="is-flex" href="#Binary-Functions"><span class="mr-2">13.1</span><span>Binary Functions</span></a></li><li><a class="is-flex" href="#Applicative"><span class="mr-2">13.2</span><span>Applicative</span></a><ul class="menu-list"><li><a class="is-flex" href="#Using-Applicative"><span class="mr-2">13.2.1</span><span>Using Applicative</span></a></li><li><a class="is-flex" href="#Relationship-to-Functor"><span class="mr-2">13.2.2</span><span>Relationship to Functor</span></a></li><li><a class="is-flex" href="#Applicative-laws"><span class="mr-2">13.2.3</span><span>Applicative laws</span></a></li><li><a class="is-flex" href="#Functor-Laws-for-Applicative"><span class="mr-2">13.2.4</span><span>Functor Laws for Applicative</span></a></li></ul></li><li><a class="is-flex" href="#Applicative-Lists"><span class="mr-2">13.3</span><span>Applicative Lists</span></a><ul class="menu-list"><li><a class="is-flex" href="#IO-and-State-s"><span class="mr-2">13.3.1</span><span>IO and State s</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Monads"><span class="mr-2">14</span><span>Monads</span></a><ul class="menu-list"><li><a class="is-flex" href="#Monad-Law"><span class="mr-2">14.1</span><span>Monad Law</span></a></li><li><a class="is-flex" href="#Relationship-to-Applicative"><span class="mr-2">14.2</span><span>Relationship to Applicative</span></a></li><li><a class="is-flex" href="#Do-notation"><span class="mr-2">14.3</span><span>Do notation</span></a></li></ul></li><li><a class="is-flex" href="#Static-Assurance-with-Types"><span class="mr-2">15</span><span>Static Assurance with Types</span></a><ul class="menu-list"><li><a class="is-flex" href="#Static-Assureance"><span class="mr-2">15.1</span><span>Static Assureance</span></a><ul class="menu-list"><li><a class="is-flex" href="#Methods-of-Assurance"><span class="mr-2">15.1.1</span><span>Methods of Assurance</span></a></li><li><a class="is-flex" href="#Static-vs-Dynamic"><span class="mr-2">15.1.2</span><span>Static vs. Dynamic</span></a></li><li><a class="is-flex" href="#Compiler-Integration"><span class="mr-2">15.1.3</span><span>Compiler Integration</span></a></li><li><a class="is-flex" href="#Types"><span class="mr-2">15.1.4</span><span>Types</span></a></li></ul></li><li><a class="is-flex" href="#Phantom-Types"><span class="mr-2">15.2</span><span>Phantom Types</span></a><ul class="menu-list"><li><a class="is-flex" href="#Validation-1"><span class="mr-2">15.2.1</span><span>Validation</span></a></li><li><a class="is-flex" href="#Units-of-Measure"><span class="mr-2">15.2.2</span><span>Units of Measure</span></a></li><li><a class="is-flex" href="#Linearity-and-Type-State"><span class="mr-2">15.2.3</span><span>Linearity and Type State</span></a></li><li><a class="is-flex" href="#Datatype-Promotion"><span class="mr-2">15.2.4</span><span>Datatype Promotion</span></a></li></ul></li><li><a class="is-flex" href="#GADTs"><span class="mr-2">15.3</span><span>GADTs</span></a><ul class="menu-list"><li><a class="is-flex" href="#GADTs-1"><span class="mr-2">15.3.1</span><span>GADTs</span></a></li><li><a class="is-flex" href="#Vectors"><span class="mr-2">15.3.2</span><span>Vectors</span></a></li><li><a class="is-flex" href="#Tradeoffs"><span class="mr-2">15.3.3</span><span>Tradeoffs</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Theory-of-Types"><span class="mr-2">16</span><span>Theory of Types</span></a><ul class="menu-list"><li><a class="is-flex" href="#Logic"><span class="mr-2">16.1</span><span>Logic</span></a><ul class="menu-list"><li><a class="is-flex" href="#Natural-Deduction"><span class="mr-2">16.1.1</span><span>Natural Deduction</span></a></li><li><a class="is-flex" href="#More-rules"><span class="mr-2">16.1.2</span><span>More rules</span></a></li><li><a class="is-flex" href="#Constructive-Logic"><span class="mr-2">16.1.3</span><span>Constructive Logic</span></a></li></ul></li><li><a class="is-flex" href="#Typed-Lambda-Calculus"><span class="mr-2">16.2</span><span>Typed Lambda Calculus</span></a><ul class="menu-list"><li><a class="is-flex" href="#Boiling-Haskell-Down"><span class="mr-2">16.2.1</span><span>Boiling Haskell Down</span></a></li><li><a class="is-flex" href="#Function-Types"><span class="mr-2">16.2.2</span><span>Function Types</span></a></li><li><a class="is-flex" href="#Constructors-and-Eliminators-for-Sums"><span class="mr-2">16.2.3</span><span>Constructors and Eliminators for Sums</span></a></li><li><a class="is-flex" href="#The-Empty-Type"><span class="mr-2">16.2.4</span><span>The Empty Type</span></a></li><li><a class="is-flex" href="#Gathering-Rules"><span class="mr-2">16.2.5</span><span>Gathering Rules</span></a></li><li><a class="is-flex" href="#Removing-Terms"><span class="mr-2">16.2.6</span><span>Removing Terms. . .</span></a></li><li><a class="is-flex" href="#The-Curry-Howard-Correspondence"><span class="mr-2">16.2.7</span><span>The Curry-Howard Correspondence</span></a></li><li><a class="is-flex" href="#Proof-Simplification"><span class="mr-2">16.2.8</span><span>Proof Simplification</span></a></li><li><a class="is-flex" href="#Applications"><span class="mr-2">16.2.9</span><span>Applications</span></a></li><li><a class="is-flex" href="#Caveats"><span class="mr-2">16.2.10</span><span>Caveats</span></a></li></ul></li><li><a class="is-flex" href="#Algebraic-Type-Isomorphism"><span class="mr-2">16.3</span><span>Algebraic Type Isomorphism</span></a><ul class="menu-list"><li><a class="is-flex" href="#Semiring-Structure"><span class="mr-2">16.3.1</span><span>Semiring Structure</span></a></li><li><a class="is-flex" href="#Isomorphism"><span class="mr-2">16.3.2</span><span>Isomorphism</span></a></li></ul></li><li><a class="is-flex" href="#Polymorphism-and-Parametricty"><span class="mr-2">16.4</span><span>Polymorphism and Parametricty</span></a><ul class="menu-list"><li><a class="is-flex" href="#Type-Quantifiers"><span class="mr-2">16.4.1</span><span>Type Quantifiers</span></a></li><li><a class="is-flex" href="#Curry-Howard"><span class="mr-2">16.4.2</span><span>Curry-Howard</span></a></li><li><a class="is-flex" href="#Constraining-Implementations"><span class="mr-2">16.4.3</span><span>Constraining Implementations</span></a></li><li><a class="is-flex" href="#Parametricity"><span class="mr-2">16.4.4</span><span>Parametricity</span></a></li><li><a class="is-flex" href="#Higher-Order-Functions-1"><span class="mr-2">16.4.5</span><span>Higher Order Functions</span></a></li><li><a class="is-flex" href="#Parametricity-Theorems"><span class="mr-2">16.4.6</span><span>Parametricity Theorems</span></a></li></ul></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-09T06:00:00.000Z">2020-08-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/09/Foundation%20of%20Concurreny/">Foundation of Concurrency</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/notes/">notes</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-01T06:00:00.000Z">2020-08-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/01/Haskell/">Haskell and functional programming</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/notes/">notes</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-01T06:00:00.000Z">2020-06-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/01/Mac%E8%A3%85spin%E5%92%8Cispin/">Mac装spin和ispin</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-21T06:00:00.000Z">2020-03-21</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/21/%E3%80%90%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7%E3%80%91Git%E5%92%8CGithub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">【双剑合璧】Git和Github使用教程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Concurrency/"><span class="tag">Concurrency</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Functional-Programming/"><span class="tag">Functional Programming</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Github/"><span class="tag">Github</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Haskell/"><span class="tag">Haskell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrency/"><span class="tag">concurrency</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spin/"><span class="tag">spin</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Tina blog" height="28"></a><p class="size-small"><span>&copy; 2020 Tina</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Email" href="mailto:tinayutong0310@gmail.com"><i class="fa fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://CutePikachu.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>