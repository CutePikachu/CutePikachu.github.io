{"pages":[{"title":"Projects","text":"My journey to the Computer Science World starts in July 2018. The followings are the projects I have at least made a fair amount of contribution. Some of them might not be open sourced, but they will shine and work as expected in the future. 2020.7 - Now awesome-unswLink: https://github.com/UNSWEEB/awesome-unswJust to collect class notes of UNSW computer science courses for students. Looking for more notes. We are welcome and seeking for contribution. 2020.7 - Now XYZSASStill in design phase. Will be a huge project. 2020.7 - Now AauthWeb link: https://aauth.link/Repo link: https://github.com/yzITI/Aauth“Auth with Anything: Fourth Party Login Service.” The goal is to make it is easier for other web developers to use third party login service. I have only contributed to front-end page yet. 2020.4 - Now AcewordsLink: https://acewords.topAn web app to help Chinese memorize foreign language words.This one is actually version2.0. I have made more than half of its backend(written in NodeJs) and about one third of its front-end(still VueJs).My journey to the backend world starts now. 2019.12 - 2020.2 YZSA-feStudent Affair system for Yangzhou Highschool of Jiangsu Province front-end.I have paticipated in this project which is currently using by Yangzhou Highschool of Jiangsu Province. This project is not open sourced and I won’t provide the link to the website because it requires students or staff account to login. 2019.9 - Now YZZX-techWebsite link: https://yzzx.techRepo link(deprecated): https://github.com/CutePikachu/yzzx-tech-deprecated-Repo link(in use): https://github.com/yzITI/yzzx-techThis is the web page for ITI(website language in Chinese).The deprecated version is not fully written by me, though I have made it suitable to view in phone. In the current version, I have written some pages(in about early 2020). 2019.7 Little littersLink: https://github.com/dsksi/cse-2019-hackathonThis was made during UNSW(university of New South Wales) cse hackathon, and our group got 3rd prize(3/40). The project itself was not complicated but it was impressive because we made it in 24 hours and only part of our team actually had some web programming experience. I wrote few components or functions in react and this was my first time coding using ReactJs. 2019.6 Building MazeLink: https://github.com/CutePikachu/BuildingMaze-FEIt is a maze game built using vue.This project was somewhat incomplete and can be inproved. However, I don’t want to change it and have decided to leave it like that.This is the project opening the door of front-end development for me. Guided by Phantomlsh.","link":"/projects/index.html"}],"posts":[{"title":"Haskell and functional programming","text":"Enjoy learning haskell but not only haskell. COMP3141Haskell IntroductionIn this course we use Haskell, because it is the most widespread language with good support for mathematically structured programming. 12f :: Int -&gt; Boolf x = (x &gt; 0) First $x$ is the input and the RHS of the equation is the Output. CurryingIn mathematics, we treat $log_{10}(x)$ and $log_2 (x)$ and ln(x) as separate functions. In Haskell, we have a single function logBase that, given a number n, produces a function for $log_n(x)$ 12345678910log10 :: Double -&gt; Doublelog10 = logBase 10log2 :: Double -&gt; Doublelog2 = logBase 2ln :: Double -&gt; Doubleln = logBase 2.71828logBase :: Double -&gt; Double -&gt; Double Function application associates to the left in Haskell, so: logBase 2 64 ≡ (logBase 2) 64 Functions of more than one argument are usually written this way in Haskell, but it is possible to use tuples instead… TuplesTuples are another way to take multiple inputs or produce multiple outputs: 1234toCartesian :: (Double, Double) -&gt; (Double, Double)toCartesian (r, theta) = (x, y) where x = r * cos theta y = r * sin theta N.B: The order of bindings doesn’t matter. Haskell functions have no side effects, they just return a result. There’s no notion of time(no notion of sth happen before sth else). Higher Order FunctionsIn addition to returning functions, functions can take other functions as arguments: 12345678twice :: (a -&gt; a) -&gt; (a -&gt; a)twice f a = f (f a)double :: Int -&gt; Intdouble x = x * 2quadruple :: Int -&gt; Intquadruple = twice double Haskell concrete types are written in upper case like Int, Bool, and in lower case if they stand for any type. 12345678{- twice twice double 3 == (twice twice double) 3 == (twice (twice double)) 3 == (twice quadruple) 3 == quadrauple (quadruple 3) == 48-} ListsHaskell makes extensive use of lists, constructed using square brackets. Each list element must be of the same type. 1234[True, False, True] :: [Bool][3, 2, 5+1] :: [Int][sin, cos] :: [Double -&gt; Double][ (3,’a’),(4,’b’) ] :: [(Int, Char)] MapA useful function is map, which, given a function, applies it to each element of a list: 123map not [True, False, True] = [False, True, False]map negate [3, -2, 4] = [-3, 2, -4]map (\\x -&gt; x + 1) [1, 2, 3] = [2, 3, 4] The last example here uses a lambda expression to define a one-use function without giving it a name. What’s the type of map? 1map :: (a -&gt; b) -&gt; [a] -&gt; [b] StringsThe type String in Haskell is just a list of characters: 1type String = [Char] This is a type synonym, like a typedef in C. Thus: &quot;hi!&quot; == ['h', 'i', '!'] Practice Word Frequencies Given a number $n$ and a string $s$, generate a report (in String form) that lists the $n$ most common words in the string $s$. We must: Break the input string into words. Convert the words to lowercase. Sort the words. Count adjacent runs of the same word. Sort by size of the run. Take the first $n$ runs in the sorted list. Generate a report. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Data.Char(toLower)import Data.List(group,sort,sortBy)breakIntoWords :: String -&gt; [String]breakIntoWords = wordsconvertIntoLowercase :: [[Char]] -&gt; [String]convertIntoLowercase = map (map toLower)sortWords :: [String] -&gt; [String]sortWords = sorttype Run = (Int, String)countAdjacentRuns :: [String] -&gt; [Run]countAdjacentRuns = convertToRuns . groupAdjacentRuns -- [\"hello\",\"hello\",\"world\"] --&gt; [[\"hello\",\"hello\"],[\"world\"]]groupAdjacentRuns :: [String] -&gt; [[String]]groupAdjacentRuns = group-- head :: [a] -&gt; aconvertToRuns :: [[String]] -&gt; [Run]convertToRuns = map (\\ls-&gt; (length ls, head ls))sortByRunSize :: [Run] -&gt; [Run]sortByRunSize = sortBy (\\(l1, w1) (l2, w2) -&gt; compare l2 l1)takeFirst :: Int -&gt; [Run] -&gt; [Run]takeFirst = take generateReport :: [Run] -&gt; StringgenerateReport = unlines . map (\\(l,w) -&gt; w ++ \":\" ++ show l ) -- (\\x -&gt; f x) == fmostCommonWords :: Int -&gt; (String -&gt; String)mostCommonWords n = generateReport . takeFirst n . sortByRunSize . countAdjacentRuns . sortWords . convertIntoLowercase . breakIntoWords Functional CompositionWe used function composition to combine our functions together. The mathematical $(f ◦ g)(x)$ is written $(f . g) x$ in Haskell. In Haskell, operators like function composition are themselves functions. You can define your own! 1234-- Vector addition(.+) :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)(x1, y1) .+ (x2, y2) = (x1 + x2, y1 + y2)(2,3) .+ (1,1) == (3,4) You could even have defined function composition yourself if it didn’t already exist: 12(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)(f . g) x = f (g x) ListsHow were all of those list functions we just used implemented? Lists are singly-linked lists in Haskell. The empty list is written as [] and a list node is written as x : xs. The value x is called the head and the rest of the list xs is called the tail. Thus: 12\"hi!\" == ['h', 'i', '!'] == 'h':('i':('!':[])) == 'h' : 'i' : '!' : [] When we define recursive functions on lists, we use the last form for pattern matching: 123map :: (a -&gt; b) -&gt; [a] -&gt; [b]map f [] = []map f (x:xs) = f x : map f xs We can evaluate programs equationally: 12345678910111213{-map toUpper \"hi!\" ≡ map toUpper (’h’:\"i!\") ≡ toUpper ’h’ : map toUpper \"i!\" ≡ ’H’ : map toUpper \"i!\" ≡ ’H’ : map toUpper (’i’:\"!\") ≡ ’H’ : toUpper ’i’ : map toUpper \"!\" ≡ ’H’ : ’I’ : map toUpper \"!\" ≡ ’H’ : ’I’ : map toUpper (’!’:\"\") ≡ ’H’ : ’I’ : ’!’ : map toUpper \"\" ≡ ’H’ : ’I’ : ’!’ : map toUpper [] ≡ ’H’ : ’I’ : ’!’ : [] ≡ \"HI!\"-} List Functions1234567891011121314151617181920212223242526272829303132333435-- in maths: f(g(x)) == (f o g)(x)myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]myMap f [] = []myMap f (x:xs) = (f x) : (myMap f xs)-- 1 : 2 : 3 : []-- 1 + 2 + 3 + 0sum' :: [Int] -&gt; Intsum' [] = 0sum' (x:xs) = x + sum xs-- [\"hello\",\"world\",\"!\"] -&gt; \"helloworld!\"-- \"hello\":\"world\":\"!\":[]-- \"hello\"++\"world\"++\"!\"++[]concat' :: [[a]] -&gt; [a]concat' [] = []concat' (xs:xss) = xs ++ concat xssfoldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' f z [] = zfoldr' f z (x:xs) = x `f` (foldr' f z xs)sum'' = foldr' (+) 0concat'' = foldr' (++) []filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]filter' p [] = []-- filter' p (x:xs) = if p x then x : filter' p xs -- else filter' p xsfilter' p (x:xs) | p x = x : filter' p xs | otherwise = filter' p xs InductionSuppose we want to prove that a property $P(n)$ holds for all natural numbers $n$. Remember that the set of natural numbers $N$ can be defined as follows: Definition of Natural Numbers Inductive definition of Natural numbers 0 is a natural number. For any natural number $n, n + 1$ is also a natural number Therefore, to show $P(n)$ for all $n$, it suffices to show: $P(0)$ (the base case), and assuming $P(k)$ (the inductive hypothesis), $⇒ P(k + 1)$ (the inductive case). Induction on Lists Haskell lists can be defined similarly to natural numbers Definition of Haskell Lists [] is a list. For any list xs, x:xs is also a list (for any item x). This means, if we want to prove that a property P(ls) holds for all lists ls, it suffices to show: P([]) (the base case) P(x:xs) for all items x, assuming the inductive hypothesis P(xs) Data TypesSo far, we have seen type synonyms using the type keyword. For a graphics library, we might define: 123456type Point = (Float, Float)type Vector = (Float, Float)type Line = (Point, Point)type Colour = (Int, Int, Int, Int) -- RGBAmovePoint :: Point -&gt; Vector -&gt; PointmovePoint (x,y) (dx,dy) = (x + dx, y + dy) But these definitions allow Points and Vectors to be used interchangeably, increasing the likelihood of errors. We can define our own compound types using the data keyword: 12data Point = Point Float Floatderiving (Show, Eq) First Point is the type name Second Point is Constructor name Floats are Constructor argument types 12345data Vector = Vector Float Floatderiving (Show, Eq)movePoint :: Point -&gt; Vector -&gt; PointmovePoint (Point x y) (Vector dx dy)= Point (x + dx) (y + dy) RecordsWe could define Colour similarly: 1data Colour = Colour Int Int Int Int But this has so many parameters, it’s hard to tell which is which. Haskell lets us declare these types as records, which is identical to the declaration style on the previous slide, but also gives us projection functions and record syntax: 12345data Colour = Colour { redC :: Int , greenC :: Int , blueC :: Int , opacityC :: Int } deriving (Show, Eq) Here, the code redC (Colour 255 128 0 255) gives 255. Enumeration TypesSimilar to enums in C and Java, we can define types to have one of a set of predefined values: 123456data LineStyle = Solid | Dashed | Dotted deriving (Show, Eq)data FillStyle = SolidFill | NoFill deriving (Show, Eq) Types with more than one constructor are called sum types Algebraic Data TypesJust as the Point constructor took two Float arguments, constructors for sum types can take parameters too, allowing us to model different kinds of shape: 12345678data PictureObject = Path [Point] Colour LineStyle | Circle Point Float Colour LineStyle FillStyle | Polygon [Point] Colour LineStyle FillStyle | Ellipse Point Float Float Float Colour LineStyle FillStyle deriving (Show, Eq)type Picture = [PictureObject] Recursive and Parametric TypesData types can also be defined with parameters, such as the well known Maybe type, defined in the standard library: 1data Maybe a = Just a | Nothing Types can also be recursive. If lists weren’t already defined in the standard library, we could define them ourselves: 1data List a = Nil | Cons a (List a) We can even define natural numbers, where 2 is encoded as Succ(Succ Zero): 1data Natural = Zero | Succ Natural Types in Design Make illegal states unrepresentable. ​ – Yaron Minsky (of Jane Street) Choose types that constrain your implementation as much as possible. Then failure scenarios are eliminated automatically. Partial Functions A partial function is a function not defined for all possible inputs. Partial functions are to be avoided, because they cause your program to crash if undefined cases are encountered. To eliminate partiality, we must either: enlarge the codomain, usually with a Maybe type: 123safeHead :: [a] -&gt; Maybe a safeHead (x:xs) = Just xsafeHead [] = Nothing constrain the domain to be more specific: 1234safeHead' :: NonEmpty a -&gt; asafeHead' (One a) = asafeHead' (Cons a _) = adata NonEmpty a = One a | Cons a (NonEmpty a) Type ClassesYou have already seen functions such as: compare, (==), (+), (show) that work on multiple types, and their corresponding constraints on type variables Ord, Eq, Num and Show. These constraints are called type classes, and can be thought of as a set of types for which certain operations are implemented. Show The Show type class is a set of types that can be converted to strings. 12class Show a where -- nothing to do with OOP show :: a -&gt; String Types are added to the type class as an instance like so: 123instance Show Bool where show True = \"True\" show False = \"False\" We can also define instances that depend on other instances: 123instance Show a =&gt; Show (Maybe a) where show (Just x) = \"Just \" ++ show x show Nothing = \"Nothing\" Fortunately for us, Haskell supports automatically deriving instances for some classes, including Show. Read Type classes can also overload based on the type returned. 12class Read a where read :: String -&gt; a Semigroup A semigroup is a pair of a set S and an operation • : S → S → S where the operation s associative. Associativity is defined as, for all a, b, c: (a • (b • c)) = ((a • b) • c) Haskell has a type class for semigroups! The associativity law is enforced only by programmer discipline: 123class Semigroup s where(&lt;&gt;) :: s -&gt; s -&gt; s-- Law: (&lt;&gt;) must be associative. What instances can you think of? Lists &amp; ++, numbers and +, numbers and * Example: Lets implement additive colour mixing: 12345678instance Semigroup Colour whereColour r1 g1 b1 a1 &lt;&gt; Colour r2 g2 b2 a2 = Colour (mix r1 r2) (mix g1 g2) (mix b1 b2) (mix a1 a2)where mix x1 x2 = min 255 (x1 + x2) Observe that associativity is satisfied. Moniod A monoid is a semigroup (S, •) equipped with a special identity element z : S such that x • z = x and z • y = y for all x, y. 12345class (Semigroup a) =&gt; Monoid a where mempty :: aFor colours, the identity element is transparent black:instance Monoid Colour where mempty = Colour 0 0 0 0 For each of the semigroups discussed previously(lists, num and +, num and *): Are they monoids? Yes If so, what is the identity element? [], 0, 1 Are there any semigroups that are not monoids? Maximum NewtypesThere are multiple possible monoid instances for numeric types like Integer: The operation (+) is associative, with identity element 0 The operation (*) is associative, with identity element 1 Haskell doesn’t use any of these, because there can be only one instance per type per class in the entire program (including all dependencies and libraries used). A common technique is to define a separate type that is represented identically to the original type, but can have its own, different type class instances. In Haskell, this is done with the newtype keyword. A newtype declaration is much like a data declaration except that there can be only one constructor and it must take exactly one argument: 12345newtype Score = S Integerinstance Semigroup Score where S x &lt;&gt; S y = S (x + y)instance Monoid Score where mempty = S 0 Here, Score is represented identically to Integer, and thus no performance penalty is incurred to convert between them. In general, newtypes are a great way to prevent mistakes. Use them frequently! Ord Ord is a type class for inequality comparison 12class Ord a where (&lt;=) :: a -&gt; a -&gt; Bool What laws should instances satisfy? For all x, y, and z: Reflexivity: x &lt;= x Transitivity: If x &lt;= y and y &lt;= z then x &lt;= z Antisymmetry: If x &lt;= y and y &lt;= x then x == y. Totality: Either x &lt;= y or y &lt;= x Relations that satisfy these four properties are called total orders(most are total orders). Without the fourth (totality), they are called partial orders(e.g. division). Eq Eq is a type class for equality or equivalence 12class Eq a where (==) :: a -&gt; a -&gt; Bool What laws should instances satisfy? For all x, y, and z: Reflexivity: x == x. Transitivity: If x == y and y == z then x == z. Symmetry: If x == y then y == x. Relations that satisfy these are called equivalence relations. Some argue that the Eq class should be only for equality, requiring stricter laws like: If x == y then f x == f y for all functions f But this is debated. FunctorsTypes and ValuesHaskell is actually comprised of two languages. The value-level language, consisting of expressions such as if, let, 3 etc. The type-level language, consisting of types Int, Bool, synonyms like String, and type constructors like Maybe, (-&gt;), [ ] etc This type level language itself has a type system! KindsJust as terms in the value level language are given types, terms in the type level language are given kinds. The most basic kind is written as *. Types such as Int and Bool have kind *. Seeing as Maybe is parameterised by one argument, Maybe has kind * -&gt; *: given a type (e.g. Int), it will return a type (Maybe Int). ListsSuppose we have a function: 1toString :: Int -&gt; String And we also have a function to give us some numbers: 1getNumbers :: Seed -&gt; [Int] How can I compose toString with getNumbers to get a function f of type Seed -&gt; [String]? we use map: f = map toString . getNumbers. What about return a Maybe Int? we can use maybe map 1234567maybeMap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe bmaybeMap f Nothing = NothingmaybeMap f (Just x) = Just (f x)maybeMap f mx = case mx of Nothing -&gt; Nothing Just x -&gt; Just (f x) We can generalise this using functor. FunctorAll of these functions are in the interface of a single type class, called Functor. 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b Unlike previous type classes we’ve seen like Ord and Semigroup, Functor is over types of kind * -&gt; *. 1234567891011121314151617181920-- Instance for tuples-- type level:-- (,) :: * -&gt; (* -&gt; *)-- (,) x :: * -&gt; *instance Functor ((,) x) where-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b-- fmap :: (a -&gt; b) -&gt; (,) x a -&gt; (,) x b-- fmap :: (a -&gt; b) -&gt; (x,a) -&gt; (x, b) fmap f (x,a) = (x, f a) -- instance for functions-- type level:-- (-&gt;) :: * -&gt; (* -&gt; *)-- (-&gt;) x :: * -&gt; *instance Functor ((-&gt;) x) where-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b-- fmap :: (a -&gt; b) -&gt; (-&gt;) x a -&gt; (-&gt;) x b-- fmap :: (a -&gt; b) -&gt; (x -&gt; a) -&gt; (x -&gt; b) fmap = (.) Functor LawsThe functor type class must obey two laws: fmap id == id(indentity law) fmap f . fmap g == fmap (f . g)(composition law, haskell use this law to do optimisation) In Haskell’s type system it’s impossible to make a total fmap function that satisfies the first law but violates the second. This is due to parametricity. Property Based TestingFree PropertiesHaskell already ensures certain properties automatically with its language design and type system. Memory is accessed where and when it is safe and permitted to be accessed (memory safety). Values of a certain static type will actually have that type at run time. Programs that are well-typed will not lead to undefined behaviour (type safety). All functions are pure: Programs won’t have side effects not declared in the type. (purely functional programming) ⇒ Most of our properties focus on the logic of our program. Logical PropertiesWe have already seen a few examples of logical properties. Example: reverse is an involution: reverse (reverse xs) == xs right identity for (++): xs ++ [] == xs transitivity of (&gt;): (a &gt; b) ∧ (b &gt; c) ⇒ (a &gt; c) The set of properties that capture all of our requirements for our program is called the functional correctness specification of our software. This defines what it means for software to be correct. ProofsLast week we saw some proof methods for Haskell programs. We could prove that our implementation meets its functional correctness specification. Such proofs certainly offer a high degree of assurance, but: Proofs must make some assumptions about the environment and the semantics of the software. Proof complexity grows with implementation complexity, sometimes drastically. If software is incorrect, a proof attempt might simply become stuck: we do not always get constructive negative feedback. Proofs can be labour and time intensive ($$$), or require highly specialised knowledge ($$$). TestingCompared to proofs: Tests typically run the actual program, so requires fewer assumptions about the language semantics or operating environment. Test complexity does not grow with implementation complexity, so long as the specification is unchanged. Incorrect software when tested leads to immediate, debuggable counter examples. Testing is typically cheaper and faster than proving. Tests care about efficiency and computability, unlike proofs(e.g. termination is provable but not computable). We lose some assurance, but gain some convenience ($$$). Property Based Testing Key idea: Generate random input values, and test properties by running them. Example(QuickCheck Property) 1234567891011121314151617181920import Test.QuickCheckimport Data.Charimport Data.List-- Testable -- Arbitrary Testable-- Arbitrary Testableprop_reverseApp :: [Int] -&gt; ([Int] -&gt; Bool)prop_reverseApp xs ys = reverse (xs ++ ys) == reverse ys ++ reverse xsdivisible :: Int -&gt; Int -&gt; Booldivisible x y = x `mod` y == 0-- or select different generators with modifier newtypes.prop_refl :: Positive Int -&gt; Bool prop_refl (Positive x) = divisible x x-- Encode pre-conditions with the (==&gt;) operator:prop_unwordsWords s = unwords (words s) == sprop_wordsUnwords l = all (\\w -&gt; all (not . isSpace) w &amp;&amp; w /= []) l ==&gt; words (unwords l) == l PBT vs. Unit Testing Properties are more compact than unit tests, and describe more cases. ⇒ Less testing code Property-based testing heavily depends on test data generation: Random inputs may not be as informative as hand-crafted inputs ⇒ use shrinking(When a test fails, it finds the smallest test case still falls) Random inputs may not cover all necessary corner cases: ⇒ use a coverage checker Random inputs must be generated for user-defined types: ⇒ QuickCheck includes functions to build custom generators By increasing the number of random inputs, we improve code coverage in PBT. Test Data GenerationData which can be generated randomly is represented by the following type class: 123class Arbitrary a where arbitrary :: Gen a -- more on this later shrink :: a -&gt; [a] Most of the types we have seen so far implement Arbitrary. Shrinking The shrink function is for when test cases fail. If a given input x fails, QuickCheck will try all inputs in shrink x; repeating the process until the smallest possible input is found Testable TypesThe type of the quickCheck function is: 12-- more on IO laterquickCheck :: (Testable a) =&gt; a -&gt; IO () The Testable type class is the class of things that can be converted into properties. This includes: Bool values QuickCheck’s built-in Property type Any function from an Arbitrary input to a Testable output: 12instance (Arbitrary i, Testable o) =&gt; Testable (i -&gt; o) ... Thus the type [Int] -&gt; [Int] -&gt; Bool (as used earlier) is Testable. Examples12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455split :: [a] -&gt; ([a],[a])split [] = ([],[])split [a] = ([a],[])split (x:y:xs) = let (l,r) = split xs in (x:l,y:r)prop_splitPerm xs = let (l,r) = split (xs :: [Int]) in permutation xs (l ++ r)permutation :: (Ord a) =&gt; [a] -&gt; [a] -&gt; Boolpermutation xs ys = sort xs == sort yspermutation' :: (Eq a) =&gt; [a] -&gt; [a] -&gt; (a -&gt; Bool)permutation' xs ys = \\x -&gt; count x xs == count x ys where count x l = length (filter (== x) l)merge :: (Ord a) =&gt; [a] -&gt; [a] -&gt; [a]merge [] ys = ysmerge xs [] = xsmerge (x:xs) (y:ys) | x &lt;= y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ysprop_mergePerm xs ys = permutation (xs ++ (ys :: [Int] )) (merge xs ys)prop_mergeSorted (Ordered xs) (Ordered ys) = sorted (merge (xs :: [Int]) ys)sorted :: Ord a =&gt; [a] -&gt; Boolsorted [] = True sorted [x] = Truesorted (x:y:xs) = x &lt;= y &amp;&amp; sorted (y:xs)mergeSort :: (Ord a) =&gt; [a] -&gt; [a]mergeSort [] = []mergeSort [x] = [x]mergeSort xs = let (l,r) = split xs in merge (mergeSort l) (mergeSort r)prop_mergeSortSorts xs = sorted (mergeSort (xs :: [Int])) prop_mergeSortPerm xs = permutation xs (mergeSort (xs :: [Int]))prop_mergeSortExtra xs = mergeSort (xs :: [Int]) == sort xsprop_mergeSortUnit = mergeSort [3,2,1] == [1,2,3]main = do quickCheck prop_mergeSortUnit quickCheck prop_mergeSortSorts quickCheck prop_mergeSortPerm Redundant PropertiesSome properties are technically redundant (i.e. implied by other properties in the specification), but there is some value in testing them anyway: They may be more efficient than full functional correctness tests, consuming less computing resources to test. They may be more fine-grained to give better test coverage than random inputs for full functional correctness tests. They provide a good sanity check to the full functional correctness properties. Sometimes full functional correctness is not easily computable but tests of weaker properties are. These redundant properties include unit tests. We can (and should) combine both approaches! Lazy Evaluation It never evaluate anything unless it has to 123sumTo :: Integer -&gt; IntegersumTo 0 = 0sumTo n = sumTo (n-1) + n This crashes when given a large number. Why? Because of the growing stack frame. 1234567891011121314sumTo' :: Integer -&gt; Integer -&gt; IntegersumTo' a 0 = asumTo' a n = sumTo' (a+n) (n-1)sumTo :: Integer -&gt; IntegersumTo 0 = 0sumTo n = sumTo (n-1) + n-- sumTo' 0 5-- sumTo' (0+5) (5-1)-- sumTo' (0+5) 4-- sumTo' (0+5+4) (4-1)-- sumTo' (0+5+4) 3-- sumTo' (0+5+4+3) (3-1)-- sumTo' (0+5+4+3) 2 -&gt; never evaluate the first argument-- .. This still crashes when given a large number. Why? This is called a space leak, and is one of the main drawbacks of Haskell’s lazy evaluation method. Haskell is lazily evaluated, also called call-by-need. This means that expressions are only evaluated when they are needed to compute a result for the user. We can force the previous program to evaluate its accumulator by using a bang pattern, or the primitive operation seq: 1234567{-# LANGUAGE BangPatterns #-}sumTo' :: Integer -&gt; Integer -&gt; IntegersumTo' !a 0 = asumTo' !a n = sumTo' (a+n) (n-1)sumTo' :: Integer -&gt; Integer -&gt; IntegersumTo' a 0 = asumTo' a n = let a' = a + n in a' `seq` sumTo' a' (n-1) AdvantagesLazy Evaluation has many advantages: It enables equational reasoning even in the presence of partial functions and non-termination It allows functions to be decomposed without sacrificing efficiency, for example: minimum = head . sort is, depending on sorting algorithm, possibly O(n). It allows for circular programming and infinite data structures, which allow us to express more things as pure functions. Infinite Data StructuresLaziness lets us define data structures that extend infinitely. Lists are a common example, but it also applies to trees or any user-defined data type: 1ones = 1 : ones Many functions such as take, drop, head, tail, filter and map work fine on infinite lists. 12345naturals = 0 : map (1+) naturals--ornaturals = map sum (inits ones)-- fibonacci numbersfibs = 1:1:zipWith (+) fibs (tail fibs) Data Invariants and ADTsStructure of a ModuleA Haskell program will usually be made up of many modules, each of which exports one or more data types. Typically a module for a data type X will also provide a set of functions, called operations, on X. to construct the data type: c :: · · · → X to query information from the data type: q :: X → · · · to update the data type: u :: · · · X → X A lot of software can be designed with this structure. Example: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module Dictionary ( Word , Definition , Dict , emptyDict , insertWord , lookup ) whereimport Prelude hiding (Word, lookup)import Test.QuickCheckimport Test.QuickCheck.Modifiers-- lookup :: [(a,b)] -&gt; a -&gt; Maybe btype Word = Stringtype Definition = Stringnewtype Dict = D [DictEntry] deriving (Show, Eq)emptyDict :: DictemptyDict = D []insertWord :: Word -&gt; Definition -&gt; Dict -&gt; DictinsertWord w def (D defs) = D (insertEntry (Entry w def) defs) where insertEntry wd (x:xs) = case compare (word wd) (word x) of GT -&gt; x : (insertEntry wd xs) EQ -&gt; wd : xs LT -&gt; wd : x : xs insertEntry wd [] = [wd]lookup :: Word -&gt; Dict -&gt; Maybe Definitionlookup w (D es) = search w es where search w [] = Nothing search w (e:es) = case compare w (word e) of LT -&gt; Nothing EQ -&gt; Just (defn e) GT -&gt; search w essorted :: (Ord a) =&gt; [a] -&gt; Boolsorted [] = Truesorted [x] = Truesorted (x:y:xs) = x &lt;= y &amp;&amp; sorted (y:xs)wellformed :: Dict -&gt; Boolwellformed (D es) = sorted esprop_insert_wf dict w d = wellformed dict ==&gt; wellformed (insertWord w d dict)data DictEntry = Entry { word :: Word , defn :: Definition } deriving (Eq, Show)instance Ord DictEntry where Entry w1 d1 &lt;= Entry w2 d2 = w1 &lt;= w2instance Arbitrary DictEntry where arbitrary = Entry &lt;$&gt; arbitrary &lt;*&gt; arbitraryinstance Arbitrary Dict where arbitrary = do Ordered ds &lt;- arbitrary pure (D ds)prop_arbitrary_wf dict = wellformed dict Data Invariants Data invariants are properties that pertain to a particular data type. Whenever we use operations on that data type, we want to know that our data invariants are maintained. For a given data type X, we define a wellformedness predicate wf :: X → Bool For a given value x :: X, wf x returns true iff our data invariants hold for the value x For each operation, if all input values of type X satisfy wf, all output values will satisfy wf. In other words, for each constructor operation c :: · · · → X, we must show wf (c · · ·), and for each update operation u :: X → X we must show wf x =⇒ wf(u x) Abstract Data Types An abstract data type (ADT) is a data type where the implementation details of the type and its associated operations are hidden. 123456newtype Dicttype Word = Stringtype Definition = StringemptyDict :: DictinsertWord :: Word -&gt; Definition -&gt; Dict -&gt; Dictlookup :: Word -&gt; Dict -&gt; Maybe Definition If we don’t have access to the implementation of Dict, then we can only access it via the provided operations, which we know preserve our data invariants. Thus, our data invariants cannot be violated if this module is correct. In general, abstraction is the process of eliminating detail. The inverse of abstraction is called refinement. Abstract data types like the dictionary above are abstract in the sense that their implementation details are hidden, and we no longer have to reason about them on the level of implementation. ValidationSuppose we had a sendEmail function 123sendEmail :: String -- email address -&gt; String -- message -&gt; IO () -- action (more in 2 wks) It is possible to mix the two String arguments, and even if we get the order right, it’s possible that the given email address is not valid. We could define a tiny ADT for validated email addresses, where the data invariant is that the contained email address is valid: 1234567module EmailADT(Email, checkEmail, sendEmail) newtype Email = Email String checkEmail :: String -&gt; Maybe Email checkEmail str | '@' `elem` str = Just (Email str) | otherwise = Nothing-- Then, change the type of sendEmail: sendEmail :: Email -&gt; String -&gt; IO() The only way (outside of the EmailADT module) to create a value of type Email is to use checkEmail. checkEmail is an example of what we call a smart constructor: a constructor that enforces data invariants. Data RefinementReasoning about ADTsConsider the following, more traditional example of an ADT interface, the unbounded queue: 123456data QueueemptyQueue :: Queueenqueue :: Int -&gt; Queue -&gt; Queuefront :: Queue -&gt; Int -- partialdequeue :: Queue -&gt; Queue -- partialsize :: Queue -&gt; Int We could try to come up with properties that relate these functions to each other without reference to their implementation, such as: dequeue (enqueue x emptyQueue) == emptyQueue However these do not capture functional correctness (usually). Models for ADTsWe could imagine a simple implementation for queues, just in terms of lists: 12345emptyQueueL = []enqueueL a = (++ [a])frontL = headdequeueL = tailsizeL = length But this implementation is O(n) to enqueue! Unacceptable! However!(This is out mental model) This is a dead simple implementation, and trivial to see that it is correct. If we make a better queue implementation, it should always give the same results as this simple one. Therefore: This implementation serves as a functional correctness specification for our Queue type! Refinement Relations The typical approach to connect our model queue to our Queue type is to define a relation, called a refinement relation, that relates a Queue to a list and tells us if the two structures represent the same queue conceptually: 1234rel :: Queue -&gt; [Int] -&gt; Boolprop_empty_r = rel emptyQueue emptyQueueLprop_size_r fq lq = rel fq lq ==&gt; size fq == sizeL lqprop_enq_ref fq lq x = rel fq lq ==&gt; rel (enqueue x fq) (enqueueL x lq) Abstraction FunctionsThese refinement relations are very difficult to use with QuickCheck because the rel fq lq preconditions are very hard to satisfy with randomly generated inputs. For this example, it’s a lot easier if we define an abstraction function that computes the corresponding abstract list from the concrete Queue. toAbstract :: Queue → [Int] Conceptually, our refinement relation is then just:] \\fq lq → absfun fq == lq However, we can re-express our properties in a much more QC-friendly format 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Test.QuickCheckemptyQueueL = []enqueueL a = (++ [a])frontL = headdequeueL = tailsizeL = lengthtoAbstract :: Queue -&gt; [Int]toAbstract (Q f sf r sr) = f ++ reverse rprop_empty_ref = toAbstract emptyQueue == emptyQueueLprop_enqueue_ref fq x = toAbstract (enqueue x fq) == enqueueL x (toAbstract fq)prop_size_ref fq = size fq == sizeL (toAbstract fq)prop_front_ref fq = size fq &gt; 0 ==&gt; front fq == frontL (toAbstract fq)prop_deq_ref fq = size fq &gt; 0 ==&gt; toAbstract (dequeue fq) == dequeueL (toAbstract fq)prop_wf_empty = wellformed emptyQueueprop_wf_enq x q = wellformed q ==&gt; wellformed (enqueue x q)prop_wf_deq x q = wellformed q &amp;&amp; size q &gt; 0 ==&gt; wellformed (dequeue q)data Queue = Q [Int] -- front of the queue Int -- size of the front [Int] -- rear of the queue Int -- size of the rear deriving (Show, Eq)wellformed :: Queue -&gt; Boolwellformed (Q f sf r sr) = length f == sf &amp;&amp; length r == sr &amp;&amp; sf &gt;= srinstance Arbitrary Queue where arbitrary = do NonNegative sf' &lt;- arbitrary NonNegative sr &lt;- arbitrary let sf = sf' + sr f &lt;- vectorOf sf arbitrary r &lt;- vectorOf sr arbitrary pure (Q f sf r sr)inv3 :: Queue -&gt; Queueinv3 (Q f sf r sr) | sf &lt; sr = Q (f ++ reverse r) (sf + sr) [] 0 | otherwise = Q f sf r sremptyQueue :: QueueemptyQueue = Q [] 0 [] 0enqueue :: Int -&gt; Queue -&gt; Queueenqueue x (Q f sf r sr) = inv3 (Q f sf (x:r) (sr+1))front :: Queue -&gt; Int -- partialfront (Q (x:f) sf r sr) = xdequeue :: Queue -&gt; Queue -- partialdequeue (Q (x:f) sf r sr) = inv3 (Q f (sf -1) r sr)size :: Queue -&gt; Intsize (Q f sf r sr) = sf + sr Data RefinementThese kinds of properties establish what is known as a data refinement from the abstract, slow, list model to the fast, concrete Queue implementation. Refinement and Specifications In general, all functional correctness specifications can be expressed as: all data invariants are maintained, and the implementation is a refinement of an abstract correctness model. There is a limit to the amount of abstraction we can do before they become useless for testing (but not necessarily for proving).","link":"/2020/08/01/Haskell/"},{"title":"Mac装spin和ispin","text":"翻了很久也没找到Mac的安装教程(可能是太简单了)， 安装spin这个就很简单了，感谢brew, 1brew install spin 安装ispin去https://github.com/nimble-code/Spin下载，可以直接打包或者git clone。其实ispin只是一个文件，在 ‘optional_gui’这个folder里（不确定只有这个文件是不是就可以直接运行）。然后我们进入ispin文件所在的目录。 1cd Spin/optional_gui 然后在命令行输入 1wish -f ispin.tcl 就可以运行了。","link":"/2020/06/01/Mac%E8%A3%85spin%E5%92%8Cispin/"},{"title":"【双剑合璧】Git和Github使用教程","text":"是否有遇到过写着写着想回到之前版本，却又不记得具体实现；又或是想和队友共享代码，每次修改发送文件；抑或是想换个电脑写却不想用email等搬运全部文件这类烦不胜烦类似的问题，伟大的程序员们自然早就为我们造好了轮子，那就是版本控制的利器——Git以及cloud based Github。本教程也主要讲Git与Github的使用。 1. 背景介绍本来想粗暴写一下安装使用教程，想了想还是先写一点背景介绍，不感兴趣可以直接跳过。 版本控制首先我们需要了解一个概念——Version Control，也就是版本控制。当我们写代码的时候总会有意无意制造出一些bug，有时候我们会想返回前一次没有问题的时候，因此这就是我们为什么需要版本控制。 简单来说，版本控制就是在不同时间节点保存你的程序，然后你可以通过它回看甚至回到之前保存的版本。 什么是GitGit是在2005年的时候初次开发出来的版本控制利器，并风靡全球。Git是一个安装并管理本地系统的工具而且可以给你提供现有文件的你保存的不同版本。因为是本地的，下载之后就不再需要网络也可以使用。 什么是GithubGithub有一点像可视化的Git，并且是在线的服务。让你可以在线管理你的Git仓库（这个具体会在后面讲）。通过Github，你可以分享你的程序，让其他合作者一起进行编辑。它不仅保存了Git的全部功能，还进行了扩充，它可以让你在任意电脑任意地区访问，只要你有权限。它最大的优点就是它是一个很庞大的数据库，你可以搜索，阅读甚至使用别人写好的程序。当然Github还有很多替代物如Gitlab之类，本文就不赘述了。 Git vs. Github简单的说，Git是一个帮助你管理和追踪本地源码历史的版本控制工具，而Github则是一个基于云端运用Git技术的让你管理Git仓库的服务。 2. Git首先，我们来康康Git的使用。 注意：所有和Git相关的命令都是git开头噢。 安装如果已经安装过，可以跳过。 Linux 如果是Fedora或其他类似的 RPM-based distribution, 譬如RHEL 和 CentOS： 1$ sudo dnf install git-all 或Debian-based distribution像Ubuntu 1$ sudo apt install git-all macOS 可以先试 1$ git --version 如果没有安装，应该会弹出安装请求，也可以去https://git-scm.com/download/mac 下载。 Windows 这个稍微有点烦，见https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 。 新建一个Git仓库安装好之后我们就可以开始用了，Git的一个仓库（Repo）就是你的一个项目。我们首先新建一个文件夹 12$ mkdir firstRepo$ cd firstRepo 初始化一个仓库 1$ git init 这时候会显示这么一行 Initialized empty Git repository in /Users/tina/Desktop/firstRepo/.git/, 后面一部分是你当前仓库的路径，会根据路径不同进行变化。通过.git我们可以知道Git其实是创建了一个隐藏文件夹，所以我们运行ls这个命令，并不会看到有关Git的信息。 添加文件我们依然先在当前目录建文件，文件类型无所谓。这里就用txt文件了。 123$ touch first.txt$ lsfirst.txt 此时我们可以看见文件里有一个文件叫first.txt，但是这个文件并不在我们Git仓库里（划重点），为了看仓库里有什么，我们使用 1234567891011$ git statusOn branch masterInitial commitUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) first.txtnothing added to commit but untracked files present (use \"git add\" to track) 这个命令我们之后具体讲，现在我们看到untracked files这里，这个的意思就是说这些个文件在当前目录下但是没有保存到我们仓库里，所以Git不会对它的改变进行追踪。把文件添加到仓库里，我们使用 1$ git add first.txt 此时first.txt已经被加进去了。如果我们想添加多个文件呢，可以把想加入的文件用空格隔开，写在后面，像这样 1$ git add file1 file2 不过我们还有一个更简单的方法，那就是. 1$ git add . 这样可以把当前目录下全部的没有track的文件都加进来（是不是很方便！） 删除文件提到添加就不得不说删除，如果一个文件不想被跟踪了怎么办呢，那就删掉啦。 1$ git rm file 注意：这个操作不会在当前目录删除文件 一个比较重要的flag --force 顾名思义, 这个flag是用来强制删除文件的。一般来说，如果你的文件没有被commit（下面就讲这个），是不可以被删除的，但是加上这个flag就可以删除了。 “截图”咳，实话实话，我也不知道commit怎么准确翻译成中文。现在我们来看Git非常非常重要的一个命令，commit。它其实就是类似一个截图，存下来你当前的项目完成情况并保存下来，以后可以回顾甚至回到当前节点。至于怎么回到我们后面再讲，现在就来进行“截图”。这个截图只是对于Git追踪的文件，所以它与add是不可分割的。 1234$ git commit -m \"Your message about the commit\"[master (root-commit) b345d9a] This is my first commit! 1 file changed, 1 insertion(+) create mode 100644 first.txt 这样就建了一个新的commit啦，看到这个b345d9a东西了么，这个是一个commit id。但是如果你对文件进行了修改，又运行了这个语句，你会看到这么一行Already Up to date. Bug？Nonono， 这就是需要我们add来参与了。因为在Git心里，你的文件还是上一次add来的，他一看，文件和上一次commit的没有变化呀，不截图不截图。所以我们要重新add一遍，这个时候的add就是一个更新的操作了，我们每次commit之前都要先add再commit。 不过，这两步某些情况下是可以合并的，变成 1$ git commit -am \"Your message about the commit\" 这样做就是更新我跟踪的所有文件并进行现有成果截图，但是如果你新建的文件还是要用单独的add来进行添加哦。 注意：这个语句千万不要瞎写哦，以后你可能会用到 分支虽然我一直刻意没有提到上面出现过几次的一个词master，它是什么呢，它是我们的主分支。想象一棵树，它就是我们的树干。分支的作用是当你想修改某个部分的代码，添加新功能，但却不想影响之前写好的代码，就可以分出一个branch，在上面进行。不同分支之间不会相互干扰，除非你进行合并等操作。 我们初始化一个Git仓库时，主分支就已经存在，在此基础上，我们可以新建自己的branch。使用 1234$ git branch branchName$ git branch* master branchName 第一个命令是新建，第二个是列出全部分支。*表示当前所在分支。切换分支我们使用 1234$ git checkout branchName$ git branch master* branchName 通常来说，我们新建一个分支就是为了切换到新分支，所以我们可以把上两步合二为一 1$ git checkout -b &lt;my branch name&gt; 注意：我们新建分支的内容是和你建分支时所在的一致，要注意新建分支时所在的branch哦，通常情况我们都是在master上加分支。 在进行写代码，修改之后，我们想把分支上内容合并至master，使用 12$ git checkout master$ git merge branchName 这里稍微有一些饶人，我们需要在master上进行merge操作来使得master与分支一致。现在我们来简单讲解下merge。 假设在master上我们有几次commit后，新建一个分支A，几次commit之后，我们想把A合并到master上。合并之前， common base—— — commit —— commit (master) ​ ｜— commit —— commit (A) 合并后 common base—— — commit —— commit (master) —— new merge commit ​ ｜— commit —— commit (A) ——｜ 这个时候master上就有了A上面的内容啦。 merge分为两种，一种是fast forward, 另外一种是3-way merge。 第一种很直接，合并前 common base—— (master) ​ ｜— commit —— commit (A) 合并后 common base—— —— new merge commit ​ ｜— commit —— commit (A) ——｜ 就不细讲Git原理，康图。 第二种其实就是第一个那个图。小朋友，你是否有很多问号，为什么就这样合并起来，而没有冲突。merge的过程很容易产生的问题就是冲突！尽管Git的merge已经很nb了，但依然不可避免产生冲突，但这些我们可以很容易地解决。 冲突这是Git里经常遇到并且要解决的问题！当你merge不同分支时，很容易遇到。为了让大家直观感受，我们创造一个冲突。 1234567891011121314151617$ git checkout master$ echo 'this is conflicted text from master' &gt; first.txt$ git commit -am 'added one line'[master 8cc7111] added one line 1 file changed, 1 insertion(+)$ git checkout branchNameSwitched to branch 'branchName'$ echo 'this is conflicted text from feature branch' &gt; first.txt$ git commit -am 'added one line'[a 23f5790] added one line 1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch 'master'$ git merge branchNameAuto-merging first.txtCONFLICT (content): Merge conflict in first.txtAutomatic merge failed; fix conflicts and then commit the result. YES!!冲突出现了，现在我们要解决它。这个时候打开此文件 1$ vim first.txt vim是最好的text editor！ 我们会看到这个 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADthis is conflicted text from master=======this is conflicted text from feature branch&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchName &lt;&lt;&lt;&lt;&lt;&lt;&lt; 和=======是告诉我们哪里有冲突，并且是哪个branch。就这个而言前第二行是master上内容而第四行则是branchName上的内容，我们选取需要内容后记得删除135行哦！ Vim使用i进行编辑，完成后esc然后打:q推出。这个时候冲突已经解决完啦，我们需要进行一次commit来结束这次的合并操作。 1$ git commit -am 'solve conflict' 其他git status其实算是看当前分支的一个状态吧，可以看到是否有未被追踪的文件，有没有变化没有被commit。使用 1$ git status git log简单粗暴，显示commit记录，使用 1$ git log 会显示出一串commit记录，每个包括id，作者，时间，分支，以及commit的时候的那个message。 切换到某次commit1$ git checkout specific-commit-id 这个commit id就需要我们去git log里面找来，嗯就是那一长串看不懂的hash。至于你具体想切换到哪个，就看你commit的时间以及你自己写的commit信息啦（滑稽）瞎写的话现在就作茧自缚了嘻嘻。 结语Git大致就讲这么多啦，想更了解具体的Git，阔以参考document。https://git-scm.com/doc 3. Github不得不说Github是真的好用，造好的轮子随便用，甚至还可以找到作业答案，当然要自己写作业了！，而且Github推出的Github desktop是真香。使用很简单，无师自通。言归正传，我们来康康Github怎么用。 注册及安装想注册的话你需要准备的东西有：一个或多个邮箱。一个账号可以绑定N个邮箱，然后去https://github.com/ 进行注册。如果是学生且想免费申请Github pro可以访问https://education.github.com/pack 。 申请完之后我们打开命令行 12$ git config --global user.name \"&lt;your_name_here&gt;\"$ git config --global user.email \"&lt;your_email@email.com&gt;\" 注意：写名字时去除括号但保留引号，邮箱使用申请时的邮箱。以及，如果只是想在当前仓库用的话，去掉global就ok了 现在我们连接ssh到Github，这样就可以通过ssh进行clone操作而不是http。先复制ssh key 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后去Github网页，点击头像，出现下拉菜单，点击Settings，在用户设置的菜单栏选择SSH and GPG keys，点击New SSH key，在title栏写上你设备的名字，方便你辨认，把刚刚复制好的key复制到key那里。然后点击添加，如果出现输密码框就输入密码。 新建仓库先去Github上建立一个新仓库，点击Repositories旁New按钮，填写Repo的名字后就可以确认建立。新建完后自动跳转到这个初始页面，在这里我们可以看到这个仓库的https地址，点击旁边的复制按钮备用。 连接仓库现在，之前Git里的操作都可以正常用了，不过效果依然存在本地，想要和云端连接，我们需要学一些新操作。首先和remote连接 1$ git remote add origin remote repository URL 这里的URL就是上一步操作复制得到的。然后 1$ git push -u origin master 运行完之后，我们就可以在Github上看到啦。每当我们想要发布一个新的分支的时候，都需要运行这个命令，要将master改成分支的名字即可。 更新当remote和本地的版本不一致时，我们会需要进行更新，可能是本地快于remote也可能是remote快于本地。我们使用git pull来拉取remote的更新，使用前要记得先commit本地的版本哦。如果要更新remote版本，我们直接用git push就可以做到了。 克隆在Github上打开你要克隆的仓库主页，点击Clone or Download，然后可以选择用https还是ssh进行克隆，复制链接，打开命令行 1$ git clone url 如果不是你的仓库，只能使用https哦，或者也可以选择下载。 Github网页既然他是有网页版的，那自然不能忽略网页版提供的服务。 搜索我要说的搜索是在页面顶部Navigation bar里的那个搜索框，在哪里可以进行关键词搜索，能检索到有相关信息的公开仓库。在搜索结果的页面，我们可以选取特定语言（这个项目使用的语言），结果的排序方法等等。还有其他一些信息，就自己去看啦。 每个仓库都会显示stars，一般来说stars越多，认可度越高，也就越好。 关于Repo因为要素过多有很多内容，我就选取部分说明，其他的功能自己康康就好啦。 文件 点到自己的任意一个仓库，我们可以直接在网上编辑文件。点开文件A，然后点击Edit就可以进行修改，修改完成后使用下方的commit进行保存。也可以直接新建文件，上传文件，删除文件等。不过比较神奇的操作是新建文件夹。具体如下： 点击Create New File，在文件名的地方输入文件夹名称并加上/, 神奇的事情发生了，文件夹就建好了。不过不可以建空文件夹哦，所以它会强行让你写一个文件名。 合作 如果想和组员共同编辑一个仓库，我们点击settings，然后Manage Access，这个时候会让你输入一下密码。进去后可以修改当前仓库权限以及邀请合作者，提供输入合作人的Github名字来进行查找和添加。 其他怎么fetch一个云端的分支（不在本地的）？ 1$ git checkout --track origin/daves_branch 如果不想用命令行怎么办？ Github Desktop你值得拥有：https://desktop.github.com/ 4. 写在最后感谢大家看完我的废话教程，这大概是本人多年一年的使用经常用到的部分，希望可以给你们带来帮助。","link":"/2020/03/21/%E3%80%90%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7%E3%80%91Git%E5%92%8CGithub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"},{"name":"Functional Programming","slug":"Functional-Programming","link":"/tags/Functional-Programming/"},{"name":"spin","slug":"spin","link":"/tags/spin/"},{"name":"concurrency","slug":"concurrency","link":"/tags/concurrency/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"}],"categories":[{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"}]}