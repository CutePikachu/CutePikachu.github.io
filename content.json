{"pages":[{"title":"Projects","text":"My journey to the Computer Science World starts in July 2018. The followings are the projects I have at least made a fair amount of contribution. Some of them might not be open sourced, but they will shine and work as expected in the future. 2020.7 - Now awesome-unswLink: https://github.com/UNSWEEB/awesome-unswJust to collect class notes of UNSW computer science courses for students. Looking for more notes. We are welcome and seeking for contribution. 2020.7 - Now XYZSASStill in design phase. Will be a huge project. 2020.7 - Now AauthWeb link: https://aauth.link/Repo link: https://github.com/yzITI/Aauth“Auth with Anything: Fourth Party Login Service.” The goal is to make it is easier for other web developers to use third party login service. I have only contributed to front-end page yet. 2020.4 - Now AcewordsLink: https://acewords.topAn web app to help Chinese memorize foreign language words.This one is actually version2.0. I have made more than half of its backend(written in NodeJs) and about one third of its front-end(still VueJs).My journey to the backend world starts now. 2019.12 - 2020.2 YZSA-feStudent Affair system for Yangzhou Highschool of Jiangsu Province front-end.I have paticipated in this project which is currently using by Yangzhou Highschool of Jiangsu Province. This project is not open sourced and I won’t provide the link to the website because it requires students or staff account to login. 2019.9 - Now YZZX-techWebsite link: https://yzzx.techRepo link(deprecated): https://github.com/CutePikachu/yzzx-tech-deprecated-Repo link(in use): https://github.com/yzITI/yzzx-techThis is the web page for ITI(website language in Chinese).The deprecated version is not fully written by me, though I have made it suitable to view in phone. In the current version, I have written some pages(in about early 2020). 2019.7 Little littersLink: https://github.com/dsksi/cse-2019-hackathonThis was made during UNSW(university of New South Wales) cse hackathon, and our group got 3rd prize(3/40). The project itself was not complicated but it was impressive because we made it in 24 hours and only part of our team actually had some web programming experience. I wrote few components or functions in react and this was my first time coding using ReactJs. 2019.6 Building MazeLink: https://github.com/CutePikachu/BuildingMaze-FEIt is a maze game built using vue.This project was somewhat incomplete and can be inproved. However, I don’t want to change it and have decided to leave it like that.This is the project opening the door of front-end development for me. Guided by Phantomlsh.","link":"/projects/index.html"}],"posts":[{"title":"Haskell and functional programming","text":"Enjoy learning haskell but not only haskell. Haskell IntroductionIn this course we use Haskell, because it is the most widespread language with good support for mathematically structured programming. 12f :: Int -&gt; Boolf x = (x &gt; 0) First $x$ is the input and the RHS of the equation is the Output. CurryingIn mathematics, we treat $log_{10}(x)$ and $log_2 (x)$ and ln(x) as separate functions. In Haskell, we have a single function logBase that, given a number n, produces a function for $log_n(x)$ 12345678910log10 :: Double -&gt; Doublelog10 = logBase 10log2 :: Double -&gt; Doublelog2 = logBase 2ln :: Double -&gt; Doubleln = logBase 2.71828logBase :: Double -&gt; Double -&gt; Double Function application associates to the left in Haskell, so: logBase 2 64 ≡ (logBase 2) 64 Functions of more than one argument are usually written this way in Haskell, but it is possible to use tuples instead… TuplesTuples are another way to take multiple inputs or produce multiple outputs: 1234toCartesian :: (Double, Double) -&gt; (Double, Double)toCartesian (r, theta) = (x, y) where x = r * cos theta y = r * sin theta N.B: The order of bindings doesn’t matter. Haskell functions have no side effects, they just return a result. There’s no notion of time(no notion of sth happen before sth else). Higher Order FunctionsIn addition to returning functions, functions can take other functions as arguments: 12345678twice :: (a -&gt; a) -&gt; (a -&gt; a)twice f a = f (f a)double :: Int -&gt; Intdouble x = x * 2quadruple :: Int -&gt; Intquadruple = twice double Haskell concrete types are written in upper case like Int, Bool, and in lower case if they stand for any type. 12345678{- twice twice double 3 == (twice twice double) 3 == (twice (twice double)) 3 == (twice quadruple) 3 == quadrauple (quadruple 3) == 48-} ListsHaskell makes extensive use of lists, constructed using square brackets. Each list element must be of the same type. 1234[True, False, True] :: [Bool][3, 2, 5+1] :: [Int][sin, cos] :: [Double -&gt; Double][ (3,’a’),(4,’b’) ] :: [(Int, Char)] MapA useful function is map, which, given a function, applies it to each element of a list: 123map not [True, False, True] = [False, True, False]map negate [3, -2, 4] = [-3, 2, -4]map (\\x -&gt; x + 1) [1, 2, 3] = [2, 3, 4] The last example here uses a lambda expression to define a one-use function without giving it a name. What’s the type of map? 1map :: (a -&gt; b) -&gt; [a] -&gt; [b] StringsThe type String in Haskell is just a list of characters: 1type String = [Char] This is a type synonym, like a typedef in C. Thus: &quot;hi!&quot; == ['h', 'i', '!'] Practice Word Frequencies Given a number $n$ and a string $s$, generate a report (in String form) that lists the $n$ most common words in the string $s$. We must: Break the input string into words. Convert the words to lowercase. Sort the words. Count adjacent runs of the same word. Sort by size of the run. Take the first $n$ runs in the sorted list. Generate a report. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Data.Char(toLower)import Data.List(group,sort,sortBy)breakIntoWords :: String -&gt; [String]breakIntoWords = wordsconvertIntoLowercase :: [[Char]] -&gt; [String]convertIntoLowercase = map (map toLower)sortWords :: [String] -&gt; [String]sortWords = sorttype Run = (Int, String)countAdjacentRuns :: [String] -&gt; [Run]countAdjacentRuns = convertToRuns . groupAdjacentRuns -- [\"hello\",\"hello\",\"world\"] --&gt; [[\"hello\",\"hello\"],[\"world\"]]groupAdjacentRuns :: [String] -&gt; [[String]]groupAdjacentRuns = group-- head :: [a] -&gt; aconvertToRuns :: [[String]] -&gt; [Run]convertToRuns = map (\\ls-&gt; (length ls, head ls))sortByRunSize :: [Run] -&gt; [Run]sortByRunSize = sortBy (\\(l1, w1) (l2, w2) -&gt; compare l2 l1)takeFirst :: Int -&gt; [Run] -&gt; [Run]takeFirst = take generateReport :: [Run] -&gt; StringgenerateReport = unlines . map (\\(l,w) -&gt; w ++ \":\" ++ show l ) -- (\\x -&gt; f x) == fmostCommonWords :: Int -&gt; (String -&gt; String)mostCommonWords n = generateReport . takeFirst n . sortByRunSize . countAdjacentRuns . sortWords . convertIntoLowercase . breakIntoWords Functional CompositionWe used function composition to combine our functions together. The mathematical $(f ◦ g)(x)$ is written $(f . g) x$ in Haskell. In Haskell, operators like function composition are themselves functions. You can define your own! 1234-- Vector addition(.+) :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)(x1, y1) .+ (x2, y2) = (x1 + x2, y1 + y2)(2,3) .+ (1,1) == (3,4) You could even have defined function composition yourself if it didn’t already exist: 12(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)(f . g) x = f (g x) ListsHow were all of those list functions we just used implemented? Lists are singly-linked lists in Haskell. The empty list is written as [] and a list node is written as x : xs. The value x is called the head and the rest of the list xs is called the tail. Thus: 12\"hi!\" == ['h', 'i', '!'] == 'h':('i':('!':[])) == 'h' : 'i' : '!' : [] When we define recursive functions on lists, we use the last form for pattern matching: 123map :: (a -&gt; b) -&gt; [a] -&gt; [b]map f [] = []map f (x:xs) = f x : map f xs We can evaluate programs equationally: 12345678910111213{-map toUpper \"hi!\" ≡ map toUpper (’h’:\"i!\") ≡ toUpper ’h’ : map toUpper \"i!\" ≡ ’H’ : map toUpper \"i!\" ≡ ’H’ : map toUpper (’i’:\"!\") ≡ ’H’ : toUpper ’i’ : map toUpper \"!\" ≡ ’H’ : ’I’ : map toUpper \"!\" ≡ ’H’ : ’I’ : map toUpper (’!’:\"\") ≡ ’H’ : ’I’ : ’!’ : map toUpper \"\" ≡ ’H’ : ’I’ : ’!’ : map toUpper [] ≡ ’H’ : ’I’ : ’!’ : [] ≡ \"HI!\"-} List Functions1234567891011121314151617181920212223242526272829303132333435-- in maths: f(g(x)) == (f o g)(x)myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]myMap f [] = []myMap f (x:xs) = (f x) : (myMap f xs)-- 1 : 2 : 3 : []-- 1 + 2 + 3 + 0sum' :: [Int] -&gt; Intsum' [] = 0sum' (x:xs) = x + sum xs-- [\"hello\",\"world\",\"!\"] -&gt; \"helloworld!\"-- \"hello\":\"world\":\"!\":[]-- \"hello\"++\"world\"++\"!\"++[]concat' :: [[a]] -&gt; [a]concat' [] = []concat' (xs:xss) = xs ++ concat xssfoldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' f z [] = zfoldr' f z (x:xs) = x `f` (foldr' f z xs)sum'' = foldr' (+) 0concat'' = foldr' (++) []filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]filter' p [] = []-- filter' p (x:xs) = if p x then x : filter' p xs -- else filter' p xsfilter' p (x:xs) | p x = x : filter' p xs | otherwise = filter' p xs InductionSuppose we want to prove that a property $P(n)$ holds for all natural numbers $n$. Remember that the set of natural numbers $N$ can be defined as follows: Definition of Natural Numbers Inductive definition of Natural numbers 0 is a natural number. For any natural number $n, n + 1$ is also a natural number Therefore, to show $P(n)$ for all $n$, it suffices to show: $P(0)$ (the base case), and assuming $P(k)$ (the inductive hypothesis), $⇒ P(k + 1)$ (the inductive case). Induction on Lists Haskell lists can be defined similarly to natural numbers Definition of Haskell Lists [] is a list. For any list xs, x:xs is also a list (for any item x). This means, if we want to prove that a property P(ls) holds for all lists ls, it suffices to show: P([]) (the base case) P(x:xs) for all items x, assuming the inductive hypothesis P(xs) Data TypesSo far, we have seen type synonyms using the type keyword. For a graphics library, we might define: 123456type Point = (Float, Float)type Vector = (Float, Float)type Line = (Point, Point)type Colour = (Int, Int, Int, Int) -- RGBAmovePoint :: Point -&gt; Vector -&gt; PointmovePoint (x,y) (dx,dy) = (x + dx, y + dy) But these definitions allow Points and Vectors to be used interchangeably, increasing the likelihood of errors. We can define our own compound types using the data keyword: 12data Point = Point Float Floatderiving (Show, Eq) First Point is the type name Second Point is Constructor name Floats are Constructor argument types 12345data Vector = Vector Float Floatderiving (Show, Eq)movePoint :: Point -&gt; Vector -&gt; PointmovePoint (Point x y) (Vector dx dy)= Point (x + dx) (y + dy) RecordsWe could define Colour similarly: 1data Colour = Colour Int Int Int Int But this has so many parameters, it’s hard to tell which is which. Haskell lets us declare these types as records, which is identical to the declaration style on the previous slide, but also gives us projection functions and record syntax: 12345data Colour = Colour { redC :: Int , greenC :: Int , blueC :: Int , opacityC :: Int } deriving (Show, Eq) Here, the code redC (Colour 255 128 0 255) gives 255. Enumeration TypesSimilar to enums in C and Java, we can define types to have one of a set of predefined values: 123456data LineStyle = Solid | Dashed | Dotted deriving (Show, Eq)data FillStyle = SolidFill | NoFill deriving (Show, Eq) Types with more than one constructor are called sum types Algebraic Data TypesJust as the Point constructor took two Float arguments, constructors for sum types can take parameters too, allowing us to model different kinds of shape: 12345678data PictureObject = Path [Point] Colour LineStyle | Circle Point Float Colour LineStyle FillStyle | Polygon [Point] Colour LineStyle FillStyle | Ellipse Point Float Float Float Colour LineStyle FillStyle deriving (Show, Eq)type Picture = [PictureObject] Recursive and Parametric TypesData types can also be defined with parameters, such as the well known Maybe type, defined in the standard library: 1data Maybe a = Just a | Nothing Types can also be recursive. If lists weren’t already defined in the standard library, we could define them ourselves: 1data List a = Nil | Cons a (List a) We can even define natural numbers, where 2 is encoded as Succ(Succ Zero): 1data Natural = Zero | Succ Natural Types in Design Make illegal states unrepresentable. ​ – Yaron Minsky (of Jane Street) Choose types that constrain your implementation as much as possible. Then failure scenarios are eliminated automatically. Partial Functions A partial function is a function not defined for all possible inputs. Partial functions are to be avoided, because they cause your program to crash if undefined cases are encountered. To eliminate partiality, we must either: enlarge the codomain, usually with a Maybe type: 123safeHead :: [a] -&gt; Maybe a safeHead (x:xs) = Just xsafeHead [] = Nothing constrain the domain to be more specific: 1234safeHead' :: NonEmpty a -&gt; asafeHead' (One a) = asafeHead' (Cons a _) = adata NonEmpty a = One a | Cons a (NonEmpty a) Type ClassesYou have already seen functions such as: compare, (==), (+), (show) that work on multiple types, and their corresponding constraints on type variables Ord, Eq, Num and Show. These constraints are called type classes, and can be thought of as a set of types for which certain operations are implemented. Show The Show type class is a set of types that can be converted to strings. 12class Show a where -- nothing to do with OOP show :: a -&gt; String Types are added to the type class as an instance like so: 123instance Show Bool where show True = \"True\" show False = \"False\" We can also define instances that depend on other instances: 123instance Show a =&gt; Show (Maybe a) where show (Just x) = \"Just \" ++ show x show Nothing = \"Nothing\" Fortunately for us, Haskell supports automatically deriving instances for some classes, including Show. Read Type classes can also overload based on the type returned. 12class Read a where read :: String -&gt; a Semigroup A semigroup is a pair of a set S and an operation • : S → S → S where the operation s associative. Associativity is defined as, for all a, b, c: (a • (b • c)) = ((a • b) • c) Haskell has a type class for semigroups! The associativity law is enforced only by programmer discipline: 123class Semigroup s where(&lt;&gt;) :: s -&gt; s -&gt; s-- Law: (&lt;&gt;) must be associative. What instances can you think of? Lists &amp; ++, numbers and +, numbers and * Example: Lets implement additive colour mixing: 12345678instance Semigroup Colour whereColour r1 g1 b1 a1 &lt;&gt; Colour r2 g2 b2 a2 = Colour (mix r1 r2) (mix g1 g2) (mix b1 b2) (mix a1 a2)where mix x1 x2 = min 255 (x1 + x2) Observe that associativity is satisfied. Moniod A monoid is a semigroup (S, •) equipped with a special identity element z : S such that x • z = x and z • y = y for all x, y. 12345class (Semigroup a) =&gt; Monoid a where mempty :: aFor colours, the identity element is transparent black:instance Monoid Colour where mempty = Colour 0 0 0 0 For each of the semigroups discussed previously(lists, num and +, num and *): Are they monoids? Yes If so, what is the identity element? [], 0, 1 Are there any semigroups that are not monoids? Maximum","link":"/2020/08/01/Haskell/"},{"title":"【双剑合璧】Git和Github使用教程","text":"是否有遇到过写着写着想回到之前版本，却又不记得具体实现；又或是想和队友共享代码，每次修改发送文件；抑或是想换个电脑写却不想用email等搬运全部文件这类烦不胜烦类似的问题，伟大的程序员们自然早就为我们造好了轮子，那就是版本控制的利器——Git以及cloud based Github。本教程也主要讲Git与Github的使用。 1. 背景介绍本来想粗暴写一下安装使用教程，想了想还是先写一点背景介绍，不感兴趣可以直接跳过。 版本控制首先我们需要了解一个概念——Version Control，也就是版本控制。当我们写代码的时候总会有意无意制造出一些bug，有时候我们会想返回前一次没有问题的时候，因此这就是我们为什么需要版本控制。 简单来说，版本控制就是在不同时间节点保存你的程序，然后你可以通过它回看甚至回到之前保存的版本。 什么是GitGit是在2005年的时候初次开发出来的版本控制利器，并风靡全球。Git是一个安装并管理本地系统的工具而且可以给你提供现有文件的你保存的不同版本。因为是本地的，下载之后就不再需要网络也可以使用。 什么是GithubGithub有一点像可视化的Git，并且是在线的服务。让你可以在线管理你的Git仓库（这个具体会在后面讲）。通过Github，你可以分享你的程序，让其他合作者一起进行编辑。它不仅保存了Git的全部功能，还进行了扩充，它可以让你在任意电脑任意地区访问，只要你有权限。它最大的优点就是它是一个很庞大的数据库，你可以搜索，阅读甚至使用别人写好的程序。当然Github还有很多替代物如Gitlab之类，本文就不赘述了。 Git vs. Github简单的说，Git是一个帮助你管理和追踪本地源码历史的版本控制工具，而Github则是一个基于云端运用Git技术的让你管理Git仓库的服务。 2. Git首先，我们来康康Git的使用。 注意：所有和Git相关的命令都是git开头噢。 安装如果已经安装过，可以跳过。 Linux 如果是Fedora或其他类似的 RPM-based distribution, 譬如RHEL 和 CentOS： 1$ sudo dnf install git-all 或Debian-based distribution像Ubuntu 1$ sudo apt install git-all macOS 可以先试 1$ git --version 如果没有安装，应该会弹出安装请求，也可以去https://git-scm.com/download/mac 下载。 Windows 这个稍微有点烦，见https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 。 新建一个Git仓库安装好之后我们就可以开始用了，Git的一个仓库（Repo）就是你的一个项目。我们首先新建一个文件夹 12$ mkdir firstRepo$ cd firstRepo 初始化一个仓库 1$ git init 这时候会显示这么一行 Initialized empty Git repository in /Users/tina/Desktop/firstRepo/.git/, 后面一部分是你当前仓库的路径，会根据路径不同进行变化。通过.git我们可以知道Git其实是创建了一个隐藏文件夹，所以我们运行ls这个命令，并不会看到有关Git的信息。 添加文件我们依然先在当前目录建文件，文件类型无所谓。这里就用txt文件了。 123$ touch first.txt$ lsfirst.txt 此时我们可以看见文件里有一个文件叫first.txt，但是这个文件并不在我们Git仓库里（划重点），为了看仓库里有什么，我们使用 1234567891011$ git statusOn branch masterInitial commitUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) first.txtnothing added to commit but untracked files present (use \"git add\" to track) 这个命令我们之后具体讲，现在我们看到untracked files这里，这个的意思就是说这些个文件在当前目录下但是没有保存到我们仓库里，所以Git不会对它的改变进行追踪。把文件添加到仓库里，我们使用 1$ git add first.txt 此时first.txt已经被加进去了。如果我们想添加多个文件呢，可以把想加入的文件用空格隔开，写在后面，像这样 1$ git add file1 file2 不过我们还有一个更简单的方法，那就是. 1$ git add . 这样可以把当前目录下全部的没有track的文件都加进来（是不是很方便！） 删除文件提到添加就不得不说删除，如果一个文件不想被跟踪了怎么办呢，那就删掉啦。 1$ git rm file 注意：这个操作不会在当前目录删除文件 一个比较重要的flag --force 顾名思义, 这个flag是用来强制删除文件的。一般来说，如果你的文件没有被commit（下面就讲这个），是不可以被删除的，但是加上这个flag就可以删除了。 “截图”咳，实话实话，我也不知道commit怎么准确翻译成中文。现在我们来看Git非常非常重要的一个命令，commit。它其实就是类似一个截图，存下来你当前的项目完成情况并保存下来，以后可以回顾甚至回到当前节点。至于怎么回到我们后面再讲，现在就来进行“截图”。这个截图只是对于Git追踪的文件，所以它与add是不可分割的。 1234$ git commit -m \"Your message about the commit\"[master (root-commit) b345d9a] This is my first commit! 1 file changed, 1 insertion(+) create mode 100644 first.txt 这样就建了一个新的commit啦，看到这个b345d9a东西了么，这个是一个commit id。但是如果你对文件进行了修改，又运行了这个语句，你会看到这么一行Already Up to date. Bug？Nonono， 这就是需要我们add来参与了。因为在Git心里，你的文件还是上一次add来的，他一看，文件和上一次commit的没有变化呀，不截图不截图。所以我们要重新add一遍，这个时候的add就是一个更新的操作了，我们每次commit之前都要先add再commit。 不过，这两步某些情况下是可以合并的，变成 1$ git commit -am \"Your message about the commit\" 这样做就是更新我跟踪的所有文件并进行现有成果截图，但是如果你新建的文件还是要用单独的add来进行添加哦。 注意：这个语句千万不要瞎写哦，以后你可能会用到 分支虽然我一直刻意没有提到上面出现过几次的一个词master，它是什么呢，它是我们的主分支。想象一棵树，它就是我们的树干。分支的作用是当你想修改某个部分的代码，添加新功能，但却不想影响之前写好的代码，就可以分出一个branch，在上面进行。不同分支之间不会相互干扰，除非你进行合并等操作。 我们初始化一个Git仓库时，主分支就已经存在，在此基础上，我们可以新建自己的branch。使用 1234$ git branch branchName$ git branch* master branchName 第一个命令是新建，第二个是列出全部分支。*表示当前所在分支。切换分支我们使用 1234$ git checkout branchName$ git branch master* branchName 通常来说，我们新建一个分支就是为了切换到新分支，所以我们可以把上两步合二为一 1$ git checkout -b &lt;my branch name&gt; 注意：我们新建分支的内容是和你建分支时所在的一致，要注意新建分支时所在的branch哦，通常情况我们都是在master上加分支。 在进行写代码，修改之后，我们想把分支上内容合并至master，使用 12$ git checkout master$ git merge branchName 这里稍微有一些饶人，我们需要在master上进行merge操作来使得master与分支一致。现在我们来简单讲解下merge。 假设在master上我们有几次commit后，新建一个分支A，几次commit之后，我们想把A合并到master上。合并之前， common base—— — commit —— commit (master) ​ ｜— commit —— commit (A) 合并后 common base—— — commit —— commit (master) —— new merge commit ​ ｜— commit —— commit (A) ——｜ 这个时候master上就有了A上面的内容啦。 merge分为两种，一种是fast forward, 另外一种是3-way merge。 第一种很直接，合并前 common base—— (master) ​ ｜— commit —— commit (A) 合并后 common base—— —— new merge commit ​ ｜— commit —— commit (A) ——｜ 就不细讲Git原理，康图。 第二种其实就是第一个那个图。小朋友，你是否有很多问号，为什么就这样合并起来，而没有冲突。merge的过程很容易产生的问题就是冲突！尽管Git的merge已经很nb了，但依然不可避免产生冲突，但这些我们可以很容易地解决。 冲突这是Git里经常遇到并且要解决的问题！当你merge不同分支时，很容易遇到。为了让大家直观感受，我们创造一个冲突。 1234567891011121314151617$ git checkout master$ echo 'this is conflicted text from master' &gt; first.txt$ git commit -am 'added one line'[master 8cc7111] added one line 1 file changed, 1 insertion(+)$ git checkout branchNameSwitched to branch 'branchName'$ echo 'this is conflicted text from feature branch' &gt; first.txt$ git commit -am 'added one line'[a 23f5790] added one line 1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch 'master'$ git merge branchNameAuto-merging first.txtCONFLICT (content): Merge conflict in first.txtAutomatic merge failed; fix conflicts and then commit the result. YES!!冲突出现了，现在我们要解决它。这个时候打开此文件 1$ vim first.txt vim是最好的text editor！ 我们会看到这个 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADthis is conflicted text from master=======this is conflicted text from feature branch&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchName &lt;&lt;&lt;&lt;&lt;&lt;&lt; 和=======是告诉我们哪里有冲突，并且是哪个branch。就这个而言前第二行是master上内容而第四行则是branchName上的内容，我们选取需要内容后记得删除135行哦！ Vim使用i进行编辑，完成后esc然后打:q推出。这个时候冲突已经解决完啦，我们需要进行一次commit来结束这次的合并操作。 1$ git commit -am 'solve conflict' 其他git status其实算是看当前分支的一个状态吧，可以看到是否有未被追踪的文件，有没有变化没有被commit。使用 1$ git status git log简单粗暴，显示commit记录，使用 1$ git log 会显示出一串commit记录，每个包括id，作者，时间，分支，以及commit的时候的那个message。 切换到某次commit1$ git checkout specific-commit-id 这个commit id就需要我们去git log里面找来，嗯就是那一长串看不懂的hash。至于你具体想切换到哪个，就看你commit的时间以及你自己写的commit信息啦（滑稽）瞎写的话现在就作茧自缚了嘻嘻。 结语Git大致就讲这么多啦，想更了解具体的Git，阔以参考document。https://git-scm.com/doc 3. Github不得不说Github是真的好用，造好的轮子随便用，甚至还可以找到作业答案，当然要自己写作业了！，而且Github推出的Github desktop是真香。使用很简单，无师自通。言归正传，我们来康康Github怎么用。 注册及安装想注册的话你需要准备的东西有：一个或多个邮箱。一个账号可以绑定N个邮箱，然后去https://github.com/ 进行注册。如果是学生且想免费申请Github pro可以访问https://education.github.com/pack 。 申请完之后我们打开命令行 12$ git config --global user.name \"&lt;your_name_here&gt;\"$ git config --global user.email \"&lt;your_email@email.com&gt;\" 注意：写名字时去除括号但保留引号，邮箱使用申请时的邮箱。以及，如果只是想在当前仓库用的话，去掉global就ok了 现在我们连接ssh到Github，这样就可以通过ssh进行clone操作而不是http。先复制ssh key 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后去Github网页，点击头像，出现下拉菜单，点击Settings，在用户设置的菜单栏选择SSH and GPG keys，点击New SSH key，在title栏写上你设备的名字，方便你辨认，把刚刚复制好的key复制到key那里。然后点击添加，如果出现输密码框就输入密码。 新建仓库先去Github上建立一个新仓库，点击Repositories旁New按钮，填写Repo的名字后就可以确认建立。新建完后自动跳转到这个初始页面，在这里我们可以看到这个仓库的https地址，点击旁边的复制按钮备用。 连接仓库现在，之前Git里的操作都可以正常用了，不过效果依然存在本地，想要和云端连接，我们需要学一些新操作。首先和remote连接 1$ git remote add origin remote repository URL 这里的URL就是上一步操作复制得到的。然后 1$ git push -u origin master 运行完之后，我们就可以在Github上看到啦。每当我们想要发布一个新的分支的时候，都需要运行这个命令，要将master改成分支的名字即可。 更新当remote和本地的版本不一致时，我们会需要进行更新，可能是本地快于remote也可能是remote快于本地。我们使用git pull来拉取remote的更新，使用前要记得先commit本地的版本哦。如果要更新remote版本，我们直接用git push就可以做到了。 克隆在Github上打开你要克隆的仓库主页，点击Clone or Download，然后可以选择用https还是ssh进行克隆，复制链接，打开命令行 1$ git clone url 如果不是你的仓库，只能使用https哦，或者也可以选择下载。 Github网页既然他是有网页版的，那自然不能忽略网页版提供的服务。 搜索我要说的搜索是在页面顶部Navigation bar里的那个搜索框，在哪里可以进行关键词搜索，能检索到有相关信息的公开仓库。在搜索结果的页面，我们可以选取特定语言（这个项目使用的语言），结果的排序方法等等。还有其他一些信息，就自己去看啦。 每个仓库都会显示stars，一般来说stars越多，认可度越高，也就越好。 关于Repo因为要素过多有很多内容，我就选取部分说明，其他的功能自己康康就好啦。 文件 点到自己的任意一个仓库，我们可以直接在网上编辑文件。点开文件A，然后点击Edit就可以进行修改，修改完成后使用下方的commit进行保存。也可以直接新建文件，上传文件，删除文件等。不过比较神奇的操作是新建文件夹。具体如下： 点击Create New File，在文件名的地方输入文件夹名称并加上/, 神奇的事情发生了，文件夹就建好了。不过不可以建空文件夹哦，所以它会强行让你写一个文件名。 合作 如果想和组员共同编辑一个仓库，我们点击settings，然后Manage Access，这个时候会让你输入一下密码。进去后可以修改当前仓库权限以及邀请合作者，提供输入合作人的Github名字来进行查找和添加。 其他怎么fetch一个云端的分支（不在本地的）？ 1$ git checkout --track origin/daves_branch 如果不想用命令行怎么办？ Github Desktop你值得拥有：https://desktop.github.com/ 4. 写在最后感谢大家看完我的废话教程，这大概是本人多年一年的使用经常用到的部分，希望可以给你们带来帮助。","link":"/2020/03/21/%E3%80%90%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7%E3%80%91Git%E5%92%8CGithub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"},{"name":"Functional Programming","slug":"Functional-Programming","link":"/tags/Functional-Programming/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"}],"categories":[{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"}]}